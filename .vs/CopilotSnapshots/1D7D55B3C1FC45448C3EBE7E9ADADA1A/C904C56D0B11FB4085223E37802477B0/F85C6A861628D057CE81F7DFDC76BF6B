# 📋 Sistema de Questionários Online

[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=flat&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-12.0-239120?style=flat&logo=c-sharp)](https://docs.microsoft.com/en-us/dotnet/csharp/)
[![Azure](https://img.shields.io/badge/Azure-Queue%20Storage-0089D6?style=flat&logo=microsoft-azure)](https://azure.microsoft.com/)
[![Infnet](https://img.shields.io/badge/Infnet-Pós--Graduação-red.svg)](https://www.infnet.edu.br/)

> Projeto desenvolvido como Trabalho de Conclusão da **Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**. Sistema empresarial para criação, gerenciamento e coleta de respostas de questionários com processamento assíncrono de alto volume usando Azure Queue Storage.

---

## 📑 **Índice**

- [Contexto Acadêmico](#-contexto-acadêmico)
- [Sobre o Projeto](#-sobre-o-projeto)
- [Desafio de Negócio](#-desafio-de-negócio)
- [Arquitetura](#-arquitetura)
- [Domínio e Entidades](#-domínio-e-entidades)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Decisões Arquiteturais](#-decisões-arquiteturais)
- [Tecnologias](#-tecnologias)
- [Funcionalidades e Endpoints](#-funcionalidades-e-endpoints)
- [Instalação e Configuração](#-instalação-e-configuração)
- [Performance e Escalabilidade](#-performance-e-escalabilidade)
- [Documentação Adicional](#-documentação-adicional)

---

## 🎓 **Contexto Acadêmico**

Este projeto foi desenvolvido como **Trabalho de Conclusão da Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**, sob a perspectiva de um **Arquiteto de Software** responsável por projetar uma solução escalável e de alta performance para uma startup.

### **Requisitos do Projeto Acadêmico**

**Cenário:**
Uma startup precisa de um sistema de questionários online para pesquisas públicas sobre eleições, com capacidade de receber respostas de **milhões de pessoas** simultaneamente através de campanhas em redes sociais.

**Restrições:**
- 👥 Time de **5 desenvolvedores** com conhecimento em **.NET e C#**
- 🔒 Obrigatoriedade de uso do **ecossistema .NET**
- ⏰ **Prazo crítico**: Eleições se aproximando (urgência de entrega)
- 📈 Escala: Suportar **milhões de respostas** simultâneas
- ✅ Simplicidade: Perguntas de **múltipla escolha**

**Objetivo:**
Elaborar diagramas (UML/C4 Model) e justificar escolhas arquiteturais para dois públicos:
1. **Desenvolvedores** (visão técnica)
2. **Usuários/Stakeholders** (visão de negócio)

---

## 🎯 **Sobre o Projeto**

O **Sistema de Questionários Online** é uma solução empresarial desenvolvida com **.NET 8** que permite a criação e gerenciamento de questionários por usuários internos (analistas da startup) e a coleta massiva de respostas de usuários externos (eleitores) de forma escalável e assíncrona.

### **Público-Alvo**
- **Usuários Internos**: Equipe da startup (criação e análise de pesquisas)
- **Usuários Externos**: Milhões de eleitores respondendo pesquisas via redes sociais
- **Desenvolvedores**: Time de 5 devs .NET/C# que implementaram a solução

---

## 🚨 **Desafio de Negócio**

Startups de pesquisa eleitoral enfrentam desafios críticos durante campanhas em redes sociais:

**📊 Volume Massivo e Imprevisível**
- 🔥 **Picos de acesso**: Posts virais podem gerar 10k+ respostas simultâneas
- 💥 **Sobrecarga do servidor**: Infraestrutura tradicional não escala rapidamente

**⚡ Performance Crítica**
- ⏱️ **Timeout**: Usuários abandonam se a resposta demora >3 segundos
- 📉 **Perda de dados**: Falhas durante picos causam perda de respostas valiosas

**🕐 Prazo Apertado**
- 🗳️ **Eleições se aproximando**: Entrega fora do prazo = prejuízo total
- 👨‍💻 **Time pequeno**: 5 desenvolvedores precisam entregar rápido

---

## 🏗️ **Arquitetura**

### **Visão Geral da Solução**

A arquitetura do projeto foi estruturada seguindo os princípios de **Clean Architecture** combinada com **Domain-Driven Design (DDD)**, resultando em um **Monolito Modular** com **processamento assíncrono via fila de mensagens**.

```mermaid
graph TB
    subgraph "🔵 PRESENTATION LAYER"
        API[Web API<br/>Controllers, Middleware, JWT]
    end

    subgraph "🟡 APPLICATION LAYER"
        Services[Services<br/>Orquestração e Validação]
    end

    subgraph "🟢 DOMAIN LAYER"
        Entities[Entities<br/>Regras de Negócio]
    end

    subgraph "🟣 INFRASTRUCTURE LAYER"
        Repos[Repositories<br/>EF Core, Azure Queue]
    end

    subgraph "🔴 CROSS-CUTTING LAYER"
        DI[Dependency Injection<br/>Extensions, Constants]
    end

    subgraph "⚫ WORKERS LAYER"
        Functions[Azure Functions<br/>Background Processing]
    end

    API --> Services
    Services --> Entities
    Services --> Repos
    DI -.-> API
    DI -.-> Services
    DI -.-> Repos
    Functions --> Repos

    style Entities fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Services fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style API fill:#e1f5ff,stroke:#01579b,stroke-width:2px
    style Repos fill:#d1c4e9,stroke:#4527a0,stroke-width:2px
    style DI fill:#ffccbc,stroke:#d84315,stroke-width:2px
    style Functions fill:#424242,stroke:#212121,stroke-width:2px
```

**Princípios aplicados:**
- ✅ **Clean Architecture**: Camadas isoladas com inversão de dependência
- ✅ **DDD**: Aggregate Roots, Value Objects, Rich Domain Model
- ✅ **Processamento Assíncrono**: Fila absorve picos de carga
- ✅ **Monolito Modular**: Simplicidade agora, evolução futura facilitada

### **Processamento Assíncrono com Azure Queue Storage**

A coleta de respostas dos questionários é realizada de forma assíncrona utilizando o **Azure Queue Storage**, garantindo escalabilidade e resiliência durante picos de acesso.

**Fluxo de Respostas:**
1. Usuário externo preenche o questionário na aplicação web.
2. A resposta é enviada para a **Azure Queue** como uma mensagem.
3. Um **Worker (Azure Function)** processa a mensagem da fila e armazena a resposta no banco de dados.
4. Caso ocorra algum erro, a mensagem é reenviada para a fila até 5 vezes, após isso vai para a **Dead Letter Queue** para análise.

**Benefícios mensuráveis:**

| Cenário | Síncrono ❌ | Assíncrono ✅ |
|---------|-------------|---------------|
| **10.000 respostas em 1 minuto** | 83 minutos (timeout) | 50 segundos (sucesso) |
| **Taxa de sucesso** | 2% (98% perdidas) | 100% (enfileiradas) |
| **Experiência do usuário** | Aguarda 500ms+ | Feedback em <5ms |
| **Resiliência** | Sem retry | Retry automático + DLQ |

---

## 🌐 **Domínio e Entidades**

O domínio do sistema é centrado na criação e gestão de questionários para coleta de respostas. As entidades principais foram modeladas como **Aggregate Roots** para garantir integridade e consistência nas operações.

### **Aggregate Roots**

**⭐ Questionario (Gerenciamento de Pesquisas)**
- **Responsabilidade**: Gerencia perguntas e opções com consistência transacional
- **Regras de negócio**: 
  - Factory Method `Criar()` garante estado válido inicial
  - `PodeReceberRespostas()` verifica período de coleta e status
  - `Encerrar()` muda status para `Encerrado` (imutável depois)
  - **Vinculação**: `UsuarioId` identifica o criador do questionário
- **Value Object**: `PeriodoColeta` (DataInicio, DataFim com validação)

**⭐ Resposta (Coleta de Votos)**
- **Responsabilidade**: Gerencia itens de resposta e valida completude
- **Regras de negócio**:
  - `ValidarCompletude()` garante que todas perguntas obrigatórias foram respondidas
  - `AdicionarItem()` valida se pergunta pertence ao questionário
  - **Anonimato**: Não vincula usuário, apenas `OrigemResposta` (hash IP + UserAgent)
- **Value Object**: `OrigemResposta` (para detectar duplicatas sem identificar eleitor)

**⭐ Usuario (Autenticação)**
- **Responsabilidade**: Gerencia autenticação de analistas da startup
- **Regras de negócio**:
  - `ValidarSenha()` com BCrypt (hash + salt automático)
  - `Ativo` flag (desabilitar sem deletar)
  - `AlterarRole()` para mudança de papéis (Admin, Visualizador)
- **Value Object**: `Email` (validação de formato)

---

## 📁 **Estrutura do Projeto**

A organização do código segue rigorosamente a **Clean Architecture**, com cada camada em um projeto separado para garantir baixo acoplamento e alta coesão:

```
QuestionarioOnline/
│
├── 📁 QuestionarioOnline.Api/              # 🔵 PRESENTATION LAYER
│   ├── Controllers/
│   │   ├── QuestionarioController.cs       # CRUD de questionários
│   │   ├── RespostaController.cs           # Enfileirar respostas
│   │   └── AuthController.cs               # Login JWT
│   ├── Services/
│   │   └── AuthService.cs                  # Geração de tokens JWT
│   ├── Responses/
│   │   └── ApiResponse.cs                  # Padronização de responses
│   └── Program.cs                           # Startup (DI, Middleware, Swagger)
│
├── 📁 QuestionarioOnline.Application/       # 🟡 APPLICATION LAYER
│   ├── Services/
│   │   ├── QuestionarioService.cs          # Casos de uso (Criar, Listar, Encerrar)
│   │   └── RespostaService.cs              # Enfileirar resposta
│   ├── Interfaces/
│   │   ├── IQuestionarioService.cs
│   │   └── IRespostaService.cs
│   ├── DTOs/
│   │   ├── Requests/
│   │   │   ├── CriarQuestionarioRequest.cs
│   │   │   └── RegistrarRespostaRequest.cs
│   │   └── Responses/
│   │       ├── QuestionarioDto.cs
│   │       └── RespostaRegistradaDto.cs
│   └── Validators/
│       └── CriarQuestionarioValidator.cs    # FluentValidation
│
├── 📁 QuestionarioOnline.Domain/            # 🟢 DOMAIN LAYER (CORE)
│   ├── Entities/
│   │   ├── Questionario.cs ⭐              # Aggregate Root (Factory, regras)
│   │   ├── Resposta.cs ⭐                  # Aggregate Root (validação)
│   │   └── Usuario.cs ⭐                    # Aggregate Root (autenticação)
│   ├── ValueObjects/
│   │   ├── Email.cs                         # Validação de formato
│   │   ├── PeriodoColeta.cs                 # DataInicio < DataFim
│   │   └── OrigemResposta.cs                # Hash para anonimato
│   ├── Enums/
│   │   └── StatusQuestionario.cs            # Ativo, Encerrado, Rascunho
│   └── Interfaces/
│       ├── IQuestionarioRepository.cs       # Contrato (sem implementação)
│       ├── IRespostaRepository.cs
│       └── IMessageQueue.cs                 # Abstração da fila
│
├── 📁 QuestionarioOnline.Infrastructure/    # 🟣 INFRASTRUCTURE LAYER
│   ├── Persistence/
│   │   ├── QuestionarioOnlineDbContext.cs   # EF Core DbContext
│   │   ├── Configurations/                  # FluentAPI (14 configurações)
│   │   │   ├── QuestionarioConfiguration.cs # Índices, relacionamentos
│   │   │   ├── PerguntaConfiguration.cs
│   │   │   ├── OpcaoRespostaConfiguration.cs
│   │   │   ├── RespostaConfiguration.cs
│   │   │   ├── RespostaItemConfiguration.cs
│   │   │   └── UsuarioConfiguration.cs
│   │   └── DbInitializer.cs                 # Seed de dados (dev)
│   ├── Repositories/
│   │   ├── QuestionarioRepository.cs        # Implementação + AsNoTracking
│   │   ├── RespostaRepository.cs
│   │   └── UsuarioRepository.cs
│   └── Messaging/
│       ├── AzureQueueStorageAdapter.cs      # Implementa IMessageQueue
│       └── MessageQueueOptions.cs           # Configuração
│
├── 📁 QuestionarioOnline.CrossCutting/      # 🔴 CROSS-CUTTING LAYER
│   └── DependencyInjection/
│       └── DependencyInjectionConfig.cs     # Registro de serviços, repos
│
├── 📁 QuestionarioOnline.Workers.Function/  # ⚫ WORKERS LAYER
│   ├── ProcessarRespostaFunction.cs         # Azure Function (Queue Trigger)
│   └── Program.cs                           # Configuração
│
└── 📁 docs/                                  # 📚 Documentação Técnica
    ├── ARQUITETURA_COMPLETA.md
    ├── EF_CORE_CONFIGURATION.md
    ├── JWT_AUTHENTICATION_GUIDE.md
    └── MELHORIAS_PERFORMANCE.md
```

**Benefícios dessa organização:**
- ✅ **Separação clara**: Cada camada em um projeto separado (namespace isolado)
- ✅ **Testabilidade**: Domain e Application testados sem Infrastructure
- ✅ **Manutenibilidade**: Mudanças em uma camada não afetam outras
- ✅ **Evolução**: Fácil extrair módulos para microservices (fronteiras já existem)


---

## 🎯 **Decisões Arquiteturais**

### **1. 🏢 Por que Monolito Modular (não Microservices)?**

**Contexto:**  
Startup com time de 5 desenvolvedores e prazo de 3 meses para entregar sistema funcional antes das eleições.

**Decisão:**  
Adotar **Monolito Modular** com **Clean Architecture**, mantendo fronteiras claras entre módulos (Questionario, Resposta, Auth) para facilitar futura extração como microservices.

**Justificativas:**

**✅ Pragmatismo:**
- **Prazo crítico**: Monolito = 3 meses de desenvolvimento | Microservices = 6+ meses
- **Setup simplificado**: 1 repositório, 1 pipeline CI/CD, 1 deploy
- **Debug facilitado**: Stack traces completos, sem rastreamento distribuído
- **Transações ACID**: Operações atômicas nativas (CREATE Questionario + Perguntas em 1 transação)

**✅ Time pequeno:**
- **5 desenvolvedores = 1 squad**: Todos trabalham no mesmo repositório
- **Conhecimento compartilhado**: Pull requests revisados por todos
- **Baixo overhead**: Sem necessidade de orquestração de múltiplos serviços

**⚠️ Trade-off aceito:**
- **Escala acoplada**: API, Questionario e Auth escalam juntos (mesma VM)
  - **Mitigação**: Processamento assíncrono via fila desacopla o pico de carga de respostas
- **Deploy all-or-nothing**: Mudança em Auth exige deploy completo
  - **Aceitável para MVP**: Entregas rápidas são mais importantes que deploy granular

**Caminho evolutivo:**
```
Fase 1 (Hoje - 3 meses):   Monolito Modular
Fase 2 (6-12 meses):        Worker separado (primeira extração)
Fase 3 (12-18 meses):       Microservices completo (se necessário)
```

---

### **2. ⚡ Por que Processamento Assíncrono (Fila + Azure Functions)?**

**Contexto:**  
Sistema precisa receber **10.000+ respostas simultâneas** durante campanhas virais em redes sociais (Instagram, Twitter, etc.). Processamento síncrono causaria timeout e perda de dados.

**Decisão:**  
Adotar **fila de mensagens (Azure Queue Storage)** + **Azure Functions** para processar respostas em background, retornando `202 Accepted` imediatamente para o usuário.

**Justificativas:**

**⚡ Performance crítica:**
- **API responde em <5ms**: Enfileira mensagem e retorna imediatamente
- **Sem timeout**: Processamento pode levar minutos sem afetar experiência
- **Latência previsível**: Independente de quantas respostas chegam, API sempre responde rápido

**Cenário real (post viral):**
```
10.000 respostas em 1 minuto:

❌ Processamento síncrono:
   10.000 × 500ms = 5.000 segundos (83 minutos)
   - Timeout após 30s
   - 98% das respostas perdidas

✅ Processamento assíncrono:
   10.000 × 5ms = 50 segundos
   - 100% de sucesso (202 Accepted)
   - Worker processa em 2 minutos (background)
```

**📈 Escalabilidade automática:**
- **Azure Functions escalam de 0 a 1000 instâncias** baseado no tamanho da fila
- **Custo otimizado**: Paga apenas pelo que usa (serverless pay-per-use)

**🛡️ Resiliência:**
- **Mensagens persistidas**: Se Worker crashar, mensagem volta para fila
- **Retry automático**: 5 tentativas com backoff exponencial
- **Dead Letter Queue (DLQ)**: Mensagens problemáticas vão para fila secundária

**❌ Por que não:**
- ❌ **Service Bus**: Custo 3x maior, features desnecessárias (tópicos, subscriptions)
- ❌ **HTTP síncrono**: Timeout, sem retry, perda de dados em falhas
- ❌ **RabbitMQ**: Exige gerenciar infraestrutura (VM, cluster, HA)

---

### **3. 💾 Por que SQL Server + EF Core (não NoSQL)?**

**Contexto:**  
Dados eleitorais exigem **integridade transacional** (ACID) e **queries analíticas complexas** (agregações por Estado, Cidade, Região).

**Decisão:**  
Usar **SQL Server** com **Entity Framework Core 8**, aplicando otimizações (AsNoTracking, índices, paginação).

**Justificativas:**

**✅ ACID crítico:**
- **Integridade transacional**: Criar Questionario + Perguntas + Opções em 1 transação atômica
- **Zero margem de erro**: Dados eleitorais não podem ser inconsistentes
- **Rollback automático**: Se falhar qualquer operação, reverte tudo

**✅ Expertise do time:**
- **5 devs já conhecem SQL Server**: Curva de aprendizado zero
- **Ferramentas maduras**: SSMS, Azure Data Studio, Application Insights

**⚡ Otimizações aplicadas:**
- **AsNoTracking** (+30% performance): Queries de leitura sem Change Tracker
- **14 índices estratégicos** (+40x buscas): QuestionarioId, Estado, Cidade
- **Paginação** (Skip/Take): Suporta 100k+ questionários sem memory overflow

**❌ Por que não NoSQL:**
- ❌ **MongoDB/Cosmos DB**: Eventual consistency = risco para dados eleitorais
- ❌ **Sem JOIN nativo**: Queries analíticas complexas exigem múltiplas chamadas

---

### **4. 🔐 Por que JWT Stateless (não Session-based)?**

**Contexto:**  
Sistema precisa escalar horizontalmente (múltiplas instâncias da API) sem compartilhar estado entre servidores.

**Decisão:**  
Usar **JWT Bearer** para autenticação stateless.

**Justificativas:**

**✅ Escalabilidade horizontal:**
- **Zero estado compartilhado**: Cada instância valida JWT independentemente
- **Sem Redis/Memcached**: Não precisa cache distribuído para sessions
- **Load Balancer simples**: Qualquer instância pode atender qualquer request

**✅ Performance:**
- **Sem consulta ao DB**: Token contém claims (usuarioId, email, roles)
- **Validação local**: Verifica assinatura HMAC-SHA256 (milissegundos)

**⚠️ Por que não Session-based:**
- ❌ Exige Redis/cache distribuído (complexidade)
- ❌ Estado compartilhado entre instâncias (acoplamento)

---

### **5. 🗳️ Por que NÃO vinculamos o eleitor que vota?**

**Contexto:**  
Sistema de pesquisas eleitorais públicas precisa garantir anonimato dos eleitores enquanto impede votos duplicados.

**Decisão:**  
**NÃO armazenar** identificação pessoal do eleitor. Usar **hash SHA256** (IP + UserAgent) para validar duplicatas sem identificar pessoas.

**Justificativas:**

**✅ Legalidade e Ética:**
- **Pesquisas eleitorais públicas devem ser anônimas** (legislação eleitoral)
- **LGPD/GDPR**: Armazenar dados pessoais exige consentimento e compliance
- **Liberdade de expressão**: Eleitor vota sem medo de retaliação

**✅ Escalabilidade:**
- **Sem autenticação**: Milhões de pessoas votam sem precisar criar conta
- **Performance**: Sem consultas a tabela de usuários (apenas validação de hash)
- **Simplicidade**: Endpoint público (`POST /api/resposta`) sem JWT

**✅ Segurança e Privacidade:**
- **Zero dados sensíveis**: Sem CPF, email, nome, telefone
- **Risco baixo de vazamento**: Apenas hash irreversível no banco
- **Confiança do público**: Anonimato garantido aumenta participação

**📊 Como Garantimos Integridade SEM Identificação?**

```csharp
// Value Object - OrigemResposta
public static OrigemResposta Create(string ipAddress, string userAgent)
{
    // Gera hash SHA256 irreversível (não armazena IP/UserAgent real)
    var combined = $"{ipAddress}|{userAgent}";
    var hash = ComputeSha256(combined);  // Exemplo: "A3F5D8B2..."
    
    return new OrigemResposta(hash);
}
```

**O que o hash permite:**
- ✅ **Impedir voto duplicado**: Verifica se hash já existe no questionário
- ✅ **Análise demográfica**: Armazena Estado, Cidade, Região (dados agregados)
- ✅ **Detectar fraude em massa**: Muitas respostas do mesmo hash = suspeito
- ❌ **NÃO permite**: Identificar eleitor específico (hash é irreversível)

**Estrutura no Banco:**
```sql
CREATE TABLE Respostas (
    Id uniqueidentifier PRIMARY KEY,
    QuestionarioId uniqueidentifier NOT NULL,
    OrigemResposta_Hash nvarchar(64) NOT NULL,  -- SHA256 (anônimo!)
    Estado nvarchar(50),  -- Apenas dados demográficos
    Cidade nvarchar(100),
    DataResposta datetime2 NOT NULL
);

-- ❌ SEM: UsuarioId, CPF, Email, IP real, Nome
```

**Trade-off aceito:**
- ⚠️ **Limitação**: Eleitor do mesmo IP/navegador não pode votar 2x (mesmo questionário)
  - **Mitigação**: Aceitável para pesquisas eleitorais (1 voto por pessoa é o objetivo)
- ⚠️ **Fraude por VPN**: Eleitor pode mudar IP para votar múltiplas vezes
  - **Mitigação**: Dead Letter Queue + análise manual de padrões suspeitos

---

### **6. 🏗️ Por que Clean Architecture + DDD?**

**Contexto:**  
Time de 5 devs precisa trabalhar em paralelo sem conflitos, com código testável e preparado para evolução.

**Decisão:**  
Aplicar **Clean Architecture** (camadas isoladas) + **DDD** (Aggregate Roots, Value Objects).

**Justificativas:**

**✅ Manutenibilidade:**
- **Separação clara**: Cada dev trabalha em camada diferente
- **Baixo acoplamento**: Mudança em Infrastructure não afeta Domain
- **Código legível**: Regras de negócio isoladas em Domain

**✅ Testabilidade:**
- **Domain isolado**: Testes unitários sem mocks complexos
- **Interfaces**: Application depende de IRepository (mock fácil)

**✅ Evolução para Microservices:**
- **Fronteiras claras**: Cada módulo já está isolado
- **Comunicação via interfaces**: Fácil substituir por chamadas HTTP/gRPC

