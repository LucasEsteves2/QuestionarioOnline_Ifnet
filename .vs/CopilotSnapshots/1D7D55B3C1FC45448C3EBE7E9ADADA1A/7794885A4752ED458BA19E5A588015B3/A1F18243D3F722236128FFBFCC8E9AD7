# 📋 Sistema de Questionários Online

[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=flat&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-12.0-239120?style=flat&logo=c-sharp)](https://docs.microsoft.com/en-us/dotnet/csharp/)
[![Azure](https://img.shields.io/badge/Azure-Queue%20Storage-0089D6?style=flat&logo=microsoft-azure)](https://azure.microsoft.com/)
[![Infnet](https://img.shields.io/badge/Infnet-Pós--Graduação-red.svg)](https://www.infnet.edu.br/)

> Projeto desenvolvido como Trabalho de Conclusão da **Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**. Sistema empresarial para criação, gerenciamento e coleta de respostas de questionários com processamento assíncrono de alto volume usando Azure Queue Storage.

---

## 📑 **Índice**

- [Contexto Acadêmico](#-contexto-acadêmico)
- [Sobre o Projeto](#-sobre-o-projeto)
- [Desafio de Negócio](#-desafio-de-negócio)
- [Solução Arquitetural](#-solução-arquitetural)
- [Funcionalidades](#-funcionalidades)
- [Arquitetura](#-arquitetura)
- [Tecnologias](#-tecnologias)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Diagramas](#-diagramas)
- [Justificativas Técnicas](#-justificativas-técnicas)
- [Pré-requisitos](#-pré-requisitos)
- [Instalação](#-instalação)
- [Configuração](#-configuração)
- [Como Usar](#-como-usar)
- [API Endpoints](#-api-endpoints)
- [Padrões e Princípios](#-padrões-e-princípios)
- [Performance e Escalabilidade](#-performance-e-escalabilidade)
- [Documentação Adicional](#-documentação-adicional)

---

## 🎓 **Contexto Acadêmico**

Este projeto foi desenvolvido como **Trabalho de Conclusão da Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**, sob a perspectiva de um **Arquiteto de Software** responsável por projetar uma solução escalável e de alta performance para uma startup.

### **Requisitos do Projeto Acadêmico**

**Cenário:**
Uma startup precisa de um sistema de questionários online para pesquisas públicas sobre eleições, com capacidade de receber respostas de **milhões de pessoas** simultaneamente através de campanhas em redes sociais.

**Restrições:**
- ✅ Time de **5 desenvolvedores** com conhecimento em **.NET e C#**
- ✅ Obrigatoriedade de uso do **ecossistema .NET**
- ✅ **Prazo crítico**: Eleições se aproximando (urgência de entrega)
- ✅ Escala: Suportar **milhões de respostas** simultâneas
- ✅ Simplicidade: Perguntas de **múltipla escolha**

**Objetivo:**
Elaborar diagramas (UML/C4 Model) e justificar escolhas arquiteturais para dois públicos:
1. **Desenvolvedores** (visão técnica)
2. **Usuários/Stakeholders** (visão de negócio)

**Avaliação:**
- ✅ Pragmatismo na escolha de tecnologias
- ✅ Adequação ao prazo e recursos disponíveis
- ✅ Escalabilidade e performance
- ✅ Qualidade da documentação e justificativas

---

## 🎯 **Sobre o Projeto**

O **Sistema de Questionários Online** é uma solução empresarial desenvolvida com **.NET 8** que permite a criação e gerenciamento de questionários por usuários internos (analistas da startup) e a coleta massiva de respostas de usuários externos (eleitores) de forma escalável e assíncrona.

### **Público-Alvo**
- **Usuários Internos**: Equipe da startup (criação e análise de pesquisas)
- **Usuários Externos**: Milhões de eleitores respondendo pesquisas via redes sociais
- **Desenvolvedores**: Time de 5 devs .NET/C# que implementarão a solução

---

## 💼 **Desafio de Negócio**

### **Problema**

Startups de pesquisa eleitoral enfrentam desafios críticos durante campanhas em redes sociais:

**📊 Volume Massivo e Imprevisível**
- ⚠️ **Picos de acesso**: Posts virais podem gerar 10k+ respostas simultâneas
- ⚠️ **Sobrecarga do servidor**: Infraestrutura tradicional não escala rapidamente
- ⚠️ **Custos elevados**: Manter servidores superdimensionados 24/7

**⏱️ Performance Crítica**
- ⚠️ **Timeout**: Usuários abandonam se a resposta demora >3 segundos
- ⚠️ **Perda de dados**: Falhas durante picos causam perda de respostas valiosas
- ⚠️ **Concorrência**: Deadlocks e race conditions em writes simultâneos

**📅 Prazo Apertado**
- ⚠️ **Eleições se aproximando**: Entrega fora do prazo = prejuízo total
- ⚠️ **Time pequeno**: 5 desenvolvedores precisam entregar rápido
- ⚠️ **Simplicidade essencial**: Sem over-engineering, mas com qualidade

**💸 Risco de Negócio**
- ⚠️ Se o sistema cair durante campanha viral = **perda de credibilidade**
- ⚠️ Se respostas forem perdidas = **dados inválidos**
- ⚠️ Se não escalar = **oportunidade perdida**

---

## ✅ **Solução Arquitetural**

### **Visão Geral**

A solução foi projetada seguindo **Clean Architecture + DDD** em um **Monolito Modular**, com **processamento assíncrono via Azure Queue Storage** para garantir escalabilidade e resiliência.

**Arquitetura de Alto Nível:**
```
Usuário → Web API (.NET 8) → Azure Queue Storage → Worker (Azure Function)
                ↓                                           ↓
         SQL Server Database ←──────────────────────────────┘
```

**Princípios aplicados:**
- ✅ **Clean Architecture**: Camadas isoladas com inversão de dependência
- ✅ **DDD**: Aggregate Roots, Value Objects, Rich Domain Model
- ✅ **Processamento Assíncrono**: Fila para absorver picos de carga
- ✅ **Monolito Modular**: Simplicidade agora, evolução futura facilitada

---

### **Decisões Arquiteturais Principais**

#### **1. 🏗️ Monolito Modular (não Microservices)**

**Decisão:** Começar com monolito modular seguindo Clean Architecture.

**Justificativa:**
- ✅ **Prazo**: 3 meses até eleições (Microservices = 6+ meses)
- ✅ **Time pequeno**: 5 desenvolvedores (Microservices = overhead >50%)
- ✅ **Simplicidade**: 1 deploy, debug fácil, transações ACID nativas
- ✅ **Preparação**: Fronteiras claras via interfaces facilitam extração futura

**Trade-off aceito:**
- ⚠️ Escala acoplada (resolvido com processamento assíncrono)
- ⚠️ Deploy all-or-nothing (aceitável para MVP)

**Caminho evolutivo:**
```
Fase 1 (Hoje):    Monolito Modular (3-6 meses)
Fase 2 (Futuro):  Worker separado (6-12 meses)
Fase 3 (Escala):  Microservices completo (12-18 meses)
```

---

#### **2. 🚀 Processamento Assíncrono (Azure Queue + Functions)**

**Decisão:** Respostas são enfileiradas e processadas em background.

**Justificativa:**
- ✅ **Performance**: API retorna `202 Accepted` em <5ms (não bloqueia usuário)
- ✅ **Escala**: Azure Functions escalam automaticamente (0 a 1000 instâncias)
- ✅ **Resiliência**: Mensagens persistidas (retry + dead letter queue)
- ✅ **Desacoplamento**: Preparação para futura separação em microservices

**Comparação técnica:**

| Solução | Latência | Custo | Escala | Resiliência |
|---------|----------|-------|--------|-------------|
| **Queue (escolhido)** ✅ | <5ms | $0.05/GB | Automática | 99.9% |
| Service Bus | ~20ms | 3x maior | Automática | 99.9% |
| HTTP Síncrono | ~500ms | Baixo | Manual | Baixa |

**Cenário real:**
```
10.000 respostas em 1 minuto (post viral):

❌ Processamento síncrono:
   10.000 × 500ms = 5.000s (83 minutos) → Timeout

✅ Processamento assíncrono:
   10.000 × 5ms = 50s → 202 Accepted
   Worker processa em background (2 minutos)
```

---

#### **3. 📊 SQL Server + EF Core (não NoSQL)**

**Decisão:** SQL Server com Entity Framework Core 8.

**Justificativa:**
- ✅ **ACID**: Integridade crítica para dados eleitorais
- ✅ **Expertise**: Time já conhece (curva aprendizado zero)
- ✅ **Queries complexas**: Agregações nativas (GROUP BY Estado, Cidade)

**Otimizações aplicadas:**
- ✅ AsNoTracking (+30% performance)
- ✅ 14 índices estratégicos (+40x buscas)
- ✅ Paginação (Skip/Take)

---

#### **4. 🔐 JWT Stateless (não Session-based)**

**Decisão:** Autenticação via JWT sem estado no servidor.

**Justificativa:**
- ✅ **Escalabilidade horizontal**: Zero estado compartilhado
- ✅ **Performance**: Sem consulta ao DB em cada request
- ✅ **Preparado para Microservices**: JWT funciona em arquitetura distribuída

---

#### **5. 📦 Clean Architecture + 6 Camadas**

**Estrutura:**
```
🔵 Presentation  → Controllers, Middleware
🟡 Application   → Services, DTOs, Validação
🟢 Domain        → Entities, Value Objects (core isolado)
🟣 Infrastructure → Repositories, EF Core, Azure Queue
🔴 Cross-Cutting → Dependency Injection
⚫ Workers        → Azure Functions (background)
```

**Dependency Rule:**
```
Presentation → Application → Domain ← Infrastructure
                             ↑
                    (Interfaces no Domain)
```

**Benefício:** Fronteiras claras facilitam extração futura de microservices.

---

### **📈 Estratégia de Evolução (Resumo)**

#### **Fase 1: Monolito Modular (ATUAL)**
```
Objetivo: Entregar MVP em 3 meses

Arquitetura:
1 API + 1 Worker + 1 Database + Fila

Benefícios:
✅ Deploy rápido | ✅ Debug simples | ✅ Transações ACID
```

#### **Fase 2: Worker Separado (6-12 meses)**
```
Objetivo: Escalar processamento independentemente

Mudança: Worker vira serviço separado
Fila: Não muda (mesmo contrato!)

Sinais para migrar:
- CPU >80% por 30min+
- Respostas demorando >5min
```

#### **Fase 3: Microservices (12-18 meses)**
```
Objetivo: Deploy e escala independentes

Arquitetura alvo:
API Gateway → Questionario Service
           → Resposta Service → Queue → Worker Service
           → Auth Service (shared)

Sinais para migrar:
- Time >10 desenvolvedores
- Database >500GB
- SLAs diferentes (B2B vs B2C)
```

**Por que Fila facilita migração?**
```
Fila = Contrato estável

Monolito:      API → Queue → Worker
Microservices: Service → Queue → Worker Service
                         ↑
                   Mesmo contrato! Zero refatoração.
```

**Pragmatismo > Perfeição:**
```
MVP rápido (3 meses)      = Monolito ✅
Sobreviver eleições (6 meses) = Fila + Worker ✅
Crescer sustentável (12+ meses) = Microservices ✅

Anti-pattern:
❌ Começar com Microservices = 12 meses
   Resultado: Startup morre antes das eleições
```

---

## 📁 **Estrutura do Projeto**

```
QuestionarioOnline/
│
├── 📁 QuestionarioOnline.Api/              # 🔵 PRESENTATION LAYER
│   ├── Controllers/                         # Endpoints REST
│   ├── Services/                            # AuthService (JWT)
│   ├── Responses/                           # ApiResponse<T>
│   ├── Extensions/                          # ClaimsPrincipalExtensions
│   └── Program.cs                           # Startup e Middleware
│
├── 📁 QuestionarioOnline.Application/       # 🟡 APPLICATION LAYER
│   ├── Services/                            # Lógica de aplicação
│   ├── Interfaces/                          # Contratos de serviços
│   ├── DTOs/                                # Request/Response DTOs
│   └── Validators/                          # FluentValidation
│
├── 📁 QuestionarioOnline.Domain/            # 🟢 DOMAIN LAYER
│   ├── Entities/                            # Entidades (Aggregate Roots)
│   │   ├── Questionario.cs ⭐
│   │   ├── Resposta.cs ⭐
│   │   └── UsuarioInterno.cs ⭐
│   ├── ValueObjects/                        # Value Objects
│   │   ├── Email.cs
│   │   ├── PeriodoColeta.cs
│   │   └── OrigemResposta.cs
│   ├── Enums/                               # Enumerações
│   ├── Interfaces/                          # Contratos de repositories
│   └── Constants/                           # Constantes de domínio
│
├── 📁 QuestionarioOnline.Infrastructure/    # 🟣 INFRASTRUCTURE LAYER
│   ├── Persistence/                         # EF Core
│   │   ├── QuestionarioOnlineDbContext.cs
│   │   ├── Configurations/                  # IEntityTypeConfiguration
│   │   └── DbInitializer.cs                 # Seed de dados
│   ├── Repositories/                        # Implementação de repositories
│   └── Messaging/                           # Azure Queue Storage Adapter
│
├── 📁 QuestionarioOnline.CrossCutting/      # 🔴 CROSS-CUTTING LAYER
│   └── DependencyInjection/                 # IoC Container
│
├── 📁 QuestionarioOnline.Workers.Function/  # ⚫ WORKERS LAYER
│   └── ProcessarRespostaFunction.cs         # Azure Function
│
└── 📁 docs/                                  # 📚 Documentação Acadêmica
    ├── ARQUITETURA_COMPLETA.md               # Diagramas C4 + UML
    ├── EF_CORE_CONFIGURATION.md              # Persistência
    ├── JWT_AUTHENTICATION_GUIDE.md           # Autenticação
    └── MELHORIAS_PERFORMANCE.md              # Otimizações
```

---

## 📐 **Diagramas**

### **1. Diagrama de Entidades (Domain Model - DDD)**

```mermaid
classDiagram
    class Questionario {
        <<Aggregate Root>>
        +Guid Id
        +string Titulo
        +StatusQuestionario Status
        +PeriodoColeta PeriodoColeta
        +IReadOnlyCollection~Pergunta~ Perguntas
        +Criar()$ Questionario
        +AdicionarPergunta(pergunta)
        +Encerrar()
        +PodeReceberRespostas() bool
    }

    class Pergunta {
        +Guid Id
        +string Texto
        +int Ordem
        +bool Obrigatoria
        +IReadOnlyCollection~OpcaoResposta~ Opcoes
    }

    class OpcaoResposta {
        +Guid Id
        +string Texto
        +int Ordem
    }

    class Resposta {
        <<Aggregate Root>>
        +Guid Id
        +Guid QuestionarioId
        +OrigemResposta OrigemResposta
        +DateTime DataResposta
        +IReadOnlyCollection~RespostaItem~ Itens
        +Criar()$ Resposta
        +AdicionarItem(item)
        +ValidarCompletude(perguntas)
    }

    class RespostaItem {
        +Guid Id
        +Guid PerguntaId
        +Guid OpcaoRespostaId
    }

    class UsuarioInterno {
        <<Aggregate Root>>
        +Guid Id
        +string Nome
        +Email Email
        +bool Ativo
        +ValidarSenha(senha) bool
    }

    Questionario "1" *-- "0..*" Pergunta
    Pergunta "1" *-- "2..*" OpcaoResposta
    Resposta "1" *-- "1..*" RespostaItem
    Questionario --> UsuarioInterno
    Resposta --> Questionario
    RespostaItem --> Pergunta
    RespostaItem --> OpcaoResposta

    style Questionario fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Resposta fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style UsuarioInterno fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
```

**Aggregate Roots (DDD):**
- ⭐ **Questionario**: Gerencia perguntas e opções (consistência transacional)
- ⭐ **Resposta**: Gerencia itens de resposta (completude validada)
- ⭐ **UsuarioInterno**: Gerencia autenticação e autorização

---

### **2. Fluxo de Comunicação entre Camadas**

```mermaid
sequenceDiagram
    actor User as 👤 Usuário
    participant API as 🔵 API<br/>(Controller)
    participant App as 🟡 Application<br/>(Service)
    participant Domain as 🟢 Domain<br/>(Entity)
    participant Infra as 🟣 Infrastructure<br/>(Repository)
    participant DB as 💾 Database

    User->>API: HTTP Request
    activate API
    
    API->>API: Validar JWT
    API->>App: Chamar Service
    activate App
    
    App->>Domain: Criar/Manipular Entidade
    activate Domain
    Domain->>Domain: Validar Regras de Negócio
    Domain-->>App: Entidade Válida
    deactivate Domain
    
    App->>Infra: Chamar Repository
    activate Infra
    Infra->>DB: SQL Query (EF Core)
    DB-->>Infra: Resultado
    Infra-->>App: Entidade Persistida
    deactivate Infra
    
    App-->>API: Result<T> (Success/Failure)
    deactivate App
    
    API-->>User: HTTP Response (ApiResponse)
    deactivate API
```

**Princípio:** Cada camada só conhece a camada adjacente (Dependency Rule).

---

### **3. Processamento Assíncrono de Respostas (Escala)**

```mermaid
sequenceDiagram
    participant User as 👤 Usuário
    participant API as Web API
    participant Queue as Azure Queue
    participant Function as Azure Function
    participant DB as SQL Server

    User->>API: POST /api/resposta
    activate API
    
    API->>API: Validar Questionário
    API->>Queue: Enfileirar Mensagem
    activate Queue
    Queue-->>API: Enfileirado
    deactivate Queue
    
    API-->>User: 202 Accepted<br/>(Processando...)
    deactivate API
    
    Note over Queue,Function: Processamento<br/>Assíncrono
    
    Queue->>Function: Trigger
    activate Function
    
    Function->>Function: Processar Mensagem
    Function->>DB: Persistir Resposta
    DB-->>Function: Sucesso
    
    Function-->>Queue: Completar Mensagem
    deactivate Function
```

**Benefícios Mensuráveis:**
- ⚡ Resposta em <5ms (vs 500ms+ síncrono)
- 🚀 Escala de 0 a 1000 instâncias (automático)
- 🔄 99.9% de disponibilidade (retry + DLQ)
- 💰 Custo otimizado (serverless pay-per-use)

---

### **4. Arquitetura C4 - Container (Visão Geral)**

```mermaid
C4Container
    title Sistema de Questionários Online - Container

    Person(user_interno, "Usuário Interno<br/>(Startup)")
    Person(user_externo, "Usuário Externo<br/>(Eleitor)")

    Container_Boundary(system, "Sistema") {
        Container(api, "Web API", ".NET 8")
        Container(function, "Azure Function", ".NET 8")
        ContainerDb(db, "Database", "SQL Server")
        ContainerQueue(queue, "Queue", "Azure Storage")
    }

    Rel(user_interno, api, "Gerencia", "HTTPS/JWT")
    Rel(user_externo, api, "Responde", "HTTPS")
    Rel(api, queue, "Enfileira")
    Rel(api, db, "Lê/Escreve")
    Rel(function, queue, "Consome")
    Rel(function, db, "Escreve")
```

---

## 🎓 **Justificativas Técnicas (Avaliação Acadêmica)**

### **1. Por que .NET 8 e não versões anteriores?**

✅ **LTS até 2026**: Estabilidade para produção (startup precisa de confiabilidade)  
✅ **Performance nativa**: 20-30% mais rápido que .NET 6 (impacto em escala)  
✅ **Expertise do time**: 5 devs já conhecem .NET (prazo crítico)  
✅ **Ecossistema maduro**: NuGet, Azure, Ferramentas (velocidade de desenvolvimento)  

### **2. Por que Azure Queue e não Service Bus ou HTTP?**

**Comparação detalhada:**

| Critério | Azure Queue ✅ | Service Bus | HTTP Síncrono | RabbitMQ |
|----------|---------------|-------------|---------------|-----------|
| **Custo** | $0.05/GB | $0.05/milhão + $10/mês | Grátis (infraestrutura) | Gerenciar VM |
| **Complexidade** | Zero config | Tópicos/Subscriptions | Timeout/Retry manual | Gerenciar cluster |
| **Durabilidade** | 99.9% | 99.9% | Sem garantia | 99% (depende config) |
| **Escala** | Automática | Automática | Manual (Load Balancer) | Manual |
| **Latência** | ~50ms | ~20ms | <5ms | ~10ms |
| **Backpressure** | Natural (fila) | Natural (fila) | ❌ (503 errors) | Natural (fila) |
| **Prazo entrega** | 1 dia | 3 dias | 2 dias | 5 dias |

**Por que Queue é suficiente?**
- ✅ **FIFO garantido**: Mensagens processadas na ordem (importante para auditoria)
- ✅ **Retry automático**: 5 tentativas (configurável) + Dead Letter Queue
- ✅ **At-least-once**: Mensagem nunca é perdida (vs HTTP que falha silenciosamente)
- ✅ **Visibilidade timeout**: Mensagem volta para fila se Worker crashar
- ✅ **Poison messages**: DLQ captura mensagens ruins (análise posterior)

**Por que NOT Service Bus?**
- ❌ **Custo 3x maior**: $10/mês base + $0.05/milhão (Queue é só $0.05/GB)
- ❌ **Over-engineering**: Tópicos/Subscriptions para 1 Worker (desnecessário)
- ❌ **Complexidade**: Filters, Rules, Sessions (não precisamos agora)
- ❌ **Curva de aprendizado**: Time precisaria estudar (aumenta prazo)

**Por que NOT HTTP entre serviços?**
```
Cenário: Worker processa 10k respostas em 2 minutos

❌ Com HTTP síncrono:
API: POST → Worker Service → Timeout após 30s
- API fica bloqueada esperando
- Se Worker crashar = dados perdidos
- Retry manual (complexo)
- Circuit breaker necessário

✅ Com Fila (atual):
API: POST → Queue (5ms) → 202 Accepted
Worker: Consome fila no seu ritmo
- API retorna imediatamente
- Se Worker crashar = mensagem volta para fila
- Retry automático (5 tentativas)
- Zero código extra
```

**Caminho para Microservices:**
```
HOJE:
Monolito → Queue → Worker (background)

FUTURO:
Resposta Service → Queue → Worker Service
                    ↑
              Mesma Queue!
              Zero refatoração!

Vantagem:
- Contrato já está desacoplado (DTO na mensagem)
- Worker já é isolado (primeira extração óbvia)
- Fila absorve picos (natural backpressure)
```

### **3. Por que Monolito Modular e não Microservices desde o início?**

**Análise de custo/benefício:**

| Aspecto | Monolito Modular ✅ | Microservices ❌ |
|---------|---------------------|------------------|
| **Prazo entrega** | 3-6 meses | 12-18 meses |
| **Complexidade inicial** | Baixa | Alta |
| **Debug** | Stack trace completo | Rastreamento distribuído |
| **Transações** | ACID nativo | Saga Pattern (complexo) |
| **Deploy** | 1 serviço (simples) | 3+ serviços (orquestrado) |
| **Latência** | ~50ms | ~200ms (3 hops) |
| **Custo inicial** | 1 App Service ($100/mês) | 3 containers ($400/mês) |
| **Escala** | Vertical (upgrade VM) | Horizontal (automático) |
| **Falha isolada** | ❌ (tudo cai) | ✅ (serviço isolado) |

**Por que Monolito agora faz sentido?**

**1. Prazo crítico (3 meses até eleições):**
```
Time: 5 desenvolvedores

Monolito:
- 1 mês: Setup (CI/CD, Database, Auth)
- 1 mês: Features core (Questionario, Resposta)
- 1 mês: Testes + Deploy
= 3 meses ✅ (entrega no prazo)

Microservices:
- 2 meses: Setup (K8s, Service Mesh, API Gateway, Observabilidade)
- 1 mês: Features core (3 serviços)
- 1 mês: Testes E2E (complexo)
- 1 mês: Debug distribuído (curva aprendizado)
- 1 mês: Tuning (latência, retry, timeout)
= 6 meses ❌ (perde eleições)
```

**2. Time pequeno (5 devs = 1 squad):**
```
Monolito:
- Todos trabalham no mesmo repo
- Pull requests simples
- Merge conflicts raros
- Conhecimento compartilhado

Microservices:
- 3 repos (Questionario, Resposta, Worker)
- 3 pipelines CI/CD
- Versionamento de APIs
- Documentação de contratos
- Overhead comunicação entre times
= Overhead >50% do tempo
```

**3. Domínio ainda em descoberta:**
```
Startup não sabe exatamente qual feature terá sucesso:

Monolito:
- Mover código entre módulos (refactor simples)
- Testar hipóteses rápido

Microservices:
- Fronteiras erradas = refatoração custosa
- Mover lógica entre serviços = reescrever comunicação
- Testar hipóteses lento (deploy 3 serviços)
```

**Por que Clean Architecture prepara para Microservices?**
```
Arquitetura atual (Monolito Modular):

QuestionarioOnline.Api
├─ Controllers/
│  ├─ QuestionarioController → IQuestionarioService
│  ├─ RespostaController → IRespostaService
│  └─ AuthController → AuthService
└─ Program.cs (startup único)

Migração futura (extração de serviço):

1. Copiar módulo:
   QuestionarioOnline.Api/Controllers/RespostaController
   → RespostaService.Api/Controllers/RespostaController

2. Mudar DI (Program.cs):
   - Remover RespostaController de Api
   - Adicionar em RespostaService

3. Comunicação já está desacoplada:
   API → Queue → Worker (não muda!)

Vantagem:
✅ Fronteiras já estão claras (interfaces)
✅ Dependências já estão invertidas (DI)
✅ Testes já estão isolados (mock de interfaces)
✅ Zero reescrita de lógica (copy-paste + ajustes)
```

**Quando migrar para Microservices?**

**Sinais técnicos (métricas reais):**
```
1. CPU >80% por 30min+ durante picos
   → Escala acoplada (API + Worker juntos)

2. Deploy travado por features não relacionadas
   → Questionario mudou, mas Resposta trava deploy

3. Database >500GB + queries lentas
   → Precisa sharding/particionamento

4. Time >10 desenvolvedores
   → Conflitos em PR, deploy all-or-nothing

5. Múltiplos clientes com SLAs diferentes
   → B2B (99.9%) vs B2C (99%)
