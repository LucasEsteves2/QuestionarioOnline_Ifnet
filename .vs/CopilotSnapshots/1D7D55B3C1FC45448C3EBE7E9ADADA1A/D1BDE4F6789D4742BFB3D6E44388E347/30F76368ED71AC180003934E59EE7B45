# 📋 Sistema de Questionários Online

[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=flat&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-12.0-239120?style=flat&logo=c-sharp)](https://docs.microsoft.com/en-us/dotnet/csharp/)
[![Azure](https://img.shields.io/badge/Azure-Queue%20Storage-0089D6?style=flat&logo=microsoft-azure)](https://azure.microsoft.com/)
[![Infnet](https://img.shields.io/badge/Infnet-Pós--Graduação-red.svg)](https://www.infnet.edu.br/)

> Projeto desenvolvido como Trabalho de Conclusão da **Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**. Sistema empresarial para criação, gerenciamento e coleta de respostas de questionários com processamento assíncrono de alto volume usando Azure Queue Storage.

---

## 📑 **Índice**

- [Contexto Acadêmico](#-contexto-acadêmico)
- [Sobre o Projeto](#-sobre-o-projeto)
- [Desafio de Negócio](#-desafio-de-negócio)
- [Arquitetura](#-arquitetura)
- [Domínio e Entidades](#-domínio-e-entidades)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Decisões Arquiteturais](#-decisões-arquiteturais)
- [Tecnologias](#-tecnologias)
- [Funcionalidades e Endpoints](#-funcionalidades-e-endpoints)
- [Instalação e Configuração](#-instalação-e-configuração)
- [Performance e Escalabilidade](#-performance-e-escalabilidade)
- [Documentação Adicional](#-documentação-adicional)

---

## 🎓 **Contexto Acadêmico**

Este projeto foi desenvolvido como **Trabalho de Conclusão da Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**, sob a perspectiva de um **Arquiteto de Software** responsável por projetar uma solução escalável e de alta performance para uma startup.

### **Requisitos do Projeto Acadêmico**

**Cenário:**
Uma startup precisa de um sistema de questionários online para pesquisas públicas sobre eleições, com capacidade de receber respostas de **milhões de pessoas** simultaneamente através de campanhas em redes sociais.

**Restrições:**
- 👥 Time de **5 desenvolvedores** com conhecimento em **.NET e C#**
- 🔒 Obrigatoriedade de uso do **ecossistema .NET**
- ⏰ **Prazo crítico**: Eleições se aproximando (urgência de entrega)
- 📈 Escala: Suportar **milhões de respostas** simultâneas
- ✅ Simplicidade: Perguntas de **múltipla escolha**

**Objetivo:**
Elaborar diagramas (UML/C4 Model) e justificar escolhas arquiteturais para dois públicos:
1. **Desenvolvedores** (visão técnica)
2. **Usuários/Stakeholders** (visão de negócio)

---

## 🎯 **Sobre o Projeto**

O **Sistema de Questionários Online** é uma solução empresarial desenvolvida com **.NET 8** que permite a criação e gerenciamento de questionários por usuários internos (analistas da startup) e a coleta massiva de respostas de usuários externos (eleitores) de forma escalável e assíncrona.

### **Público-Alvo**
- **Usuários Internos**: Equipe da startup (criação e análise de pesquisas)
- **Usuários Externos**: Milhões de eleitores respondendo pesquisas via redes sociais
- **Desenvolvedores**: Time de 5 devs .NET/C# que implementaram a solução

---

## 🚨 **Desafio de Negócio**

Startups de pesquisa eleitoral enfrentam desafios críticos durante campanhas em redes sociais:

**📊 Volume Massivo e Imprevisível**
- 🔥 **Picos de acesso**: Posts virais podem gerar 10k+ respostas simultâneas
- 💥 **Sobrecarga do servidor**: Infraestrutura tradicional não escala rapidamente

**⚡ Performance Crítica**
- ⏱️ **Timeout**: Usuários abandonam se a resposta demora >3 segundos
- 📉 **Perda de dados**: Falhas durante picos causam perda de respostas valiosas

**🕐 Prazo Apertado**
- 🗳️ **Eleições se aproximando**: Entrega fora do prazo = prejuízo total
- 👨‍💻 **Time pequeno**: 5 desenvolvedores precisam entregar rápido

---

## 🏗️ **Arquitetura**

### **Visão Geral da Solução**

A arquitetura do projeto foi estruturada seguindo os princípios de **Clean Architecture** combinada com **Domain-Driven Design (DDD)**, resultando em um **Monolito Modular** com **processamento assíncrono via fila de mensagens**.

```mermaid
graph TB
    subgraph "🔵 PRESENTATION LAYER"
        API[Web API<br/>Controllers, Middleware, JWT]
    end

    subgraph "🟡 APPLICATION LAYER"
        Services[Services<br/>Orquestração e Validação]
    end

    subgraph "🟢 DOMAIN LAYER"
        Entities[Entities<br/>Regras de Negócio]
    end

    subgraph "🟣 INFRASTRUCTURE LAYER"
        Repos[Repositories<br/>EF Core, Azure Queue]
    end

    subgraph "🔴 CROSS-CUTTING LAYER"
        DI[Dependency Injection<br/>Extensions, Constants]
    end

    subgraph "⚫ WORKERS LAYER"
        Functions[Azure Functions<br/>Background Processing]
    end

    API --> Services
    Services --> Entities
    Services --> Repos
    DI -.-> API
    DI -.-> Services
    DI -.-> Repos
    Functions --> Repos

    style Entities fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Services fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style API fill:#e1f5ff,stroke:#01579b,stroke-width:2px
    style Repos fill:#d1c4e9,stroke:#4527a0,stroke-width:2px
    style DI fill:#ffccbc,stroke:#d84315,stroke-width:2px
    style Functions fill:#424242,stroke:#212121,stroke-width:2px
```

### **Camadas da Arquitetura**

#### **🔵 Presentation Layer (API)**
Camada de apresentação que expõe os endpoints REST para consumo externo.

**Responsabilidades:**
- Receber requisições HTTP e retornar respostas padronizadas
- Validar autenticação e autorização (JWT)
- Serializar/deserializar DTOs
- Documentar API via Swagger/OpenAPI
- Aplicar middleware (CORS, Exception Handling, Logging)

**Componentes:**
- `Controllers`: QuestionarioController, RespostaController, AuthController
- `Middlewares`: ExceptionMiddleware, AuthenticationMiddleware
- `Responses`: ApiResponse<T> (padronização)

**Princípio aplicado:** Dependency Rule - Depende apenas de Application Layer

---

#### **🟡 Application Layer**
Camada de aplicação que orquestra os casos de uso do sistema.

**Responsabilidades:**
- Implementar lógica de aplicação e casos de uso
- Coordenar chamadas entre Domain e Infrastructure
- Validar entrada de dados (FluentValidation)
- Transformar entre DTOs e entidades de domínio
- Gerenciar transações

**Componentes:**
- `Services`: QuestionarioService, RespostaService
- `DTOs`: Request/Response objects
- `Validators`: CriarQuestionarioValidator
- `Interfaces`: IQuestionarioService, IRespostaService

**Princípio aplicado:** Orquestração sem regras de negócio (essas ficam no Domain)

---

#### **🟢 Domain Layer (Core)**
Núcleo do sistema que contém as regras de negócio e modelos de domínio.

**Responsabilidades:**
- Definir entidades e aggregate roots
- Implementar regras de negócio complexas
- Garantir invariantes de domínio
- Definir value objects imutáveis
- Especificar interfaces de repositórios (contratos)

**Componentes:**
- `Entities`: Questionario ⭐, Resposta ⭐, Usuario ⭐
- `Value Objects`: Email, PeriodoColeta, OrigemResposta
- `Enums`: StatusQuestionario, UsuarioRole
- `Interfaces`: IQuestionarioRepository, IRespostaRepository

**Princípio aplicado:** Domain-Driven Design - Independente de frameworks externos

---

#### **🟣 Infrastructure Layer**
Camada de infraestrutura que implementa detalhes técnicos e acesso a recursos externos.

**Responsabilidades:**
- Implementar acesso a dados (EF Core)
- Configurar mapeamento objeto-relacional (FluentAPI)
- Gerenciar conexões com serviços externos (Azure Queue)
- Implementar repositórios concretos
- Aplicar otimizações de performance (índices, AsNoTracking)

**Componentes:**
- `DbContext`: QuestionarioOnlineDbContext
- `Repositories`: QuestionarioRepository, RespostaRepository
- `Configurations`: Mapeamento EF Core (14 configurações)
- `Messaging`: AzureQueueStorageAdapter

**Princípio aplicado:** Dependency Inversion - Implementa interfaces do Domain

---

#### **🔴 Cross-Cutting Layer**
Camada transversal que conecta todas as outras via Injeção de Dependência.

**Responsabilidades:**
- Configurar container de IoC (Dependency Injection)
- Registrar serviços e repositórios
- Configurar lifetime dos objetos (Scoped, Singleton, Transient)
- Centralizar configuração de infraestrutura

**Componentes:**
- `DependencyInjectionConfig`: Registro centralizado de dependências

**Princípio aplicado:** Inversão de Controle (IoC)

---

#### **⚫ Workers Layer**
Camada de processamento assíncrono em background.

**Responsabilidades:**
- Processar mensagens da fila (Azure Queue)
- Persistir respostas de questionários de forma assíncrona
- Implementar retry e dead letter queue
- Escalar automaticamente baseado no tamanho da fila

**Componentes:**
- `ProcessarRespostaFunction`: Azure Function com Queue Trigger

**Princípio aplicado:** Escalabilidade horizontal e desacoplamento via mensageria

---

### **Fluxo de Dados (Operações Síncronas)**

Para operações administrativas (criar questionários, consultar resultados, autenticação), o sistema opera de forma **síncrona** através das camadas da Clean Architecture:

```mermaid
sequenceDiagram
    actor User as 👤 Usuário Interno
    participant API as 🔵 API<br/>(Controller)
    participant App as 🟡 Application<br/>(Service)
    participant Domain as 🟢 Domain<br/>(Entity)
    participant Infra as 🟣 Infrastructure<br/>(Repository)
    participant DB as 💾 SQL Server

    User->>API: HTTP Request
    activate API
    
    API->>API: Validar JWT
    API->>App: Chamar Service
    activate App
    
    App->>Domain: Criar/Manipular Entidade
    activate Domain
    Domain->>Domain: Validar Regras de Negócio
    Domain-->>App: Entidade Válida
    deactivate Domain
    
    App->>Infra: Chamar Repository
    activate Infra
    Infra->>DB: SQL Query (EF Core)
    DB-->>Infra: Resultado
    Infra-->>App: Entidade Persistida
    deactivate Infra
    
    App-->>API: Result<T> (Success/Failure)
    deactivate App
    
    API-->>User: HTTP Response (ApiResponse)
    deactivate API
```

**Características:**
- **Usado para**: Criar questionários, consultar resultados, autenticação
- **Latência**: ~50-100ms (aceitável para operações administrativas)
- **Garantias**: Transações ACID, feedback imediato, validação em tempo real

---

### **Fluxo de Dados (Operações Assíncronas)**

Para coleta massiva de respostas (alto volume), o sistema utiliza **processamento assíncrono** via fila de mensagens para garantir escalabilidade:

```mermaid
sequenceDiagram
    participant User as 👤 Usuário Externo
    participant API as Web API
    participant Queue as Azure Queue
    participant Function as Azure Function
    participant DB as SQL Server

    User->>API: POST /api/resposta
    activate API
    
    API->>API: Validar Questionário
    API->>Queue: Enfileirar Mensagem
    activate Queue
    Queue-->>API: Enfileirado com sucesso
    deactivate Queue
    
    API-->>User: 202 Accepted<br/>(Processando em background)
    deactivate API
    
    Note over Queue,Function: Processamento<br/>em Background
    
    Queue->>Function: Trigger (nova mensagem)
    activate Function
    
    Function->>Function: Deserializar DTO
    Function->>DB: Persistir Resposta
    activate DB
    DB-->>Function: Sucesso
    deactivate DB
    
    Function-->>Queue: Marcar como processada
    deactivate Function
```

**Características:**
- **Usado para**: Receber respostas de pesquisas (10.000+ simultâneas)
- **Latência da API**: <5ms (usuário não espera processamento)
- **Processamento**: 100-500ms por resposta (em background)
- **Escalabilidade**: Azure Functions escalam automaticamente (0 a 1000 instâncias)

**Benefícios mensuráveis:**

| Cenário | Síncrono ❌ | Assíncrono ✅ |
|---------|-------------|---------------|
| **10.000 respostas em 1 minuto** | 83 minutos (timeout) | 50 segundos (sucesso) |
| **Taxa de sucesso** | 2% (98% perdidas) | 100% (enfileiradas) |
| **Experiência do usuário** | Aguarda 500ms+ | Feedback em <5ms |
| **Resiliência** | Sem retry | Retry automático + DLQ |

---

### **Visão C4 (Container)**

O diagrama C4 Model ilustra os containers e suas interações:

```mermaid
C4Container
    title Sistema de Questionários Online

    Person(user_interno, "Usuário Interno<br/>(Startup)")
    Person(user_externo, "Usuário Externo<br/>(Eleitor)")

    Container_Boundary(system, "Sistema") {
        Container(api, "Web API", ".NET 8")
        Container(function, "Azure Function", ".NET 8")
        ContainerDb(db, "Database", "SQL Server")
        ContainerQueue(queue, "Queue", "Azure Storage")
    }

    Rel(user_interno, api, "Gerencia questionários", "HTTPS/JWT")
    Rel(user_externo, api, "Responde pesquisas", "HTTPS")
    Rel(api, queue, "Enfileira respostas", "Azure SDK")
    Rel(api, db, "CRUD questionários", "EF Core")
    Rel(function, queue, "Consome mensagens", "Trigger")
    Rel(function, db, "Persiste respostas", "EF Core")
```

---

## 📐 **Domínio e Entidades**

O sistema foi modelado seguindo **Domain-Driven Design (DDD)**, com **3 Aggregate Roots** principais que encapsulam regras de negócio:

```mermaid
classDiagram
    class Questionario {
        <<Aggregate Root>>
        +Guid Id
        +string Titulo
        +StatusQuestionario Status
        +PeriodoColeta PeriodoColeta
        +Guid UsuarioId
        +IReadOnlyCollection~Pergunta~ Perguntas
        +Criar()$ Questionario
        +AdicionarPergunta(pergunta)
        +Encerrar()
        +PodeReceberRespostas() bool
    }

    class Pergunta {
        +Guid Id
        +string Texto
        +int Ordem
        +bool Obrigatoria
        +IReadOnlyCollection~OpcaoResposta~ Opcoes
    }

    class OpcaoResposta {
        +Guid Id
        +string Texto
        +int Ordem
    }

    class Resposta {
        <<Aggregate Root>>
        +Guid Id
        +Guid QuestionarioId
        +OrigemResposta OrigemResposta
        +DateTime DataResposta
        +IReadOnlyCollection~RespostaItem~ Itens
        +Criar()$ Resposta
        +AdicionarItem(item)
        +ValidarCompletude(perguntas)
    }

    class RespostaItem {
        +Guid Id
        +Guid PerguntaId
        +Guid OpcaoRespostaId
    }

    class Usuario {
        <<Aggregate Root>>
        +Guid Id
        +string Nome
        +Email Email
        +UsuarioRole Role
        +bool Ativo
        +ValidarSenha(senha) bool
        +AlterarRole(role)
    }

    Questionario "1" *-- "0..*" Pergunta
    Pergunta "1" *-- "2..*" OpcaoResposta
    Resposta "1" *-- "1..*" RespostaItem
    Questionario --> Usuario
    Resposta --> Questionario
    RespostaItem --> Pergunta
    RespostaItem --> OpcaoResposta

    style Questionario fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px,color:#000
    style Resposta fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px,color:#000
    style Usuario fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px,color:#000
```

### **Aggregate Roots**

**⭐ Questionario (Gerenciamento de Pesquisas)**
- **Responsabilidade**: Gerencia perguntas e opções com consistência transacional
- **Regras de negócio**: 
  - Factory Method `Criar()` garante estado válido inicial
  - `PodeReceberRespostas()` verifica período de coleta e status
  - `Encerrar()` muda status para `Encerrado` (imutável depois)
  - **Vinculação**: `UsuarioId` identifica o criador do questionário
- **Value Object**: `PeriodoColeta` (DataInicio, DataFim com validação)

**⭐ Resposta (Coleta de Votos)**
- **Responsabilidade**: Gerencia itens de resposta e valida completude
- **Regras de negócio**:
  - `ValidarCompletude()` garante que todas perguntas obrigatórias foram respondidas
  - `AdicionarItem()` valida se pergunta pertence ao questionário
  - **Anonimato**: Não vincula usuário, apenas `OrigemResposta` (hash IP + UserAgent)
- **Value Object**: `OrigemResposta` (para detectar duplicatas sem identificar eleitor)

**⭐ Usuario (Autenticação)**
- **Responsabilidade**: Gerencia autenticação de analistas da startup
- **Regras de negócio**:
  - `ValidarSenha()` com BCrypt (hash + salt automático)
  - `Ativo` flag (desabilitar sem deletar)
  - `AlterarRole()` para mudança de papéis (Admin, Visualizador)
- **Value Object**: `Email` (validação de formato)

