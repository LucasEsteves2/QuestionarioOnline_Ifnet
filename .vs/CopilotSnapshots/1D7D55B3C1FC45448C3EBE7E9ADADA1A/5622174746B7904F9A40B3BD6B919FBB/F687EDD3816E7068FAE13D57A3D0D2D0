# 📨 Sistema de Mensageria - Arquitetura

## 🎯 **Decisão Arquitetural: Por que a Interface está no Application?**

### **Princípio DIP (Dependency Inversion Principle)**

```
┌─────────────────────────────────────────────────────────┐
│                     APPLICATION                         │
│  (Define O QUE precisa - lógica de negócio)            │
│                                                          │
│  ┌──────────────────────────────────────────┐          │
│  │  IMessageQueue (Interface)               │          │
│  │  - SendAsync<T>(queueName, message)      │          │
│  └──────────────────────────────────────────┘          │
│                        ▲                                 │
└────────────────────────┼─────────────────────────────────┘
                         │
                         │ Implementa (DIP)
                         │
┌────────────────────────┼─────────────────────────────────┐
│                  INFRASTRUCTURE                          │
│  (Implementa COMO fazer - detalhes técnicos)            │
│                                                          │
│  ┌──────────────────────────────────────────┐          │
│  │  AzureQueueStorageAdapter                │          │
│  │  - Usa QueueClient do Azure              │          │
│  └──────────────────────────────────────────┘          │
│                                                          │
│  ┌──────────────────────────────────────────┐          │
│  │  InMemoryMessageQueue                    │          │
│  │  - Implementação para testes             │          │
│  └──────────────────────────────────────────┘          │
│                                                          │
│  ┌──────────────────────────────────────────┐          │
│  │  RabbitMQAdapter (futuro)                │          │
│  │  - Poderia usar RabbitMQ                 │          │
│  └──────────────────────────────────────────┘          │
└──────────────────────────────────────────────────────────┘
```

---

## ✅ **Vantagens desta Arquitetura**

### **1. Application não conhece detalhes técnicos**
```csharp
// Application só sabe que pode enviar mensagens
public class RespostaService
{
    private readonly IMessageQueue _messageQueue; // Abstração
    
    public async Task RegistrarRespostaAsync(...)
    {
        await _messageQueue.SendAsync("fila", mensagem); // Não sabe se é Azure, RabbitMQ, etc.
    }
}
```

### **2. Fácil trocar provedor**
```csharp
// Produção: Azure Queue Storage
services.AddSingleton<IMessageQueue>(
    new AzureQueueStorageAdapter(azureConnectionString));

// Testes: In-Memory
services.AddSingleton<IMessageQueue>(
    new InMemoryMessageQueue());

// Futuro: RabbitMQ
services.AddSingleton<IMessageQueue>(
    new RabbitMQAdapter(rabbitMqConfig));
```

### **3. Testabilidade**
```csharp
// Teste unitário sem Azure
var messageQueue = new InMemoryMessageQueue();
var service = new RespostaService(messageQueue, ...);

await service.RegistrarRespostaAsync(request);

// Verificar se mensagem foi enviada
var messages = messageQueue.GetMessages<RespostaParaProcessamentoDto>("respostas-questionario");
Assert.Single(messages);
```

---

## 🏗️ **Por que NÃO é "Service"?**

### **❌ Confusão Semântica**
- **Service** no Domain/Application = Lógica de negócio (ex: `RespostaService`)
- **Service** no Infrastructure = Confunde! Parece negócio, mas é técnico

### **✅ Nomenclatura Correta**
- **Adapter** = Adapta tecnologia externa (Azure, RabbitMQ)
- **Gateway** = Ponto de entrada para sistema externo
- **Client** = Cliente de API externa

---

## 📦 **Implementações Disponíveis**

### **1. AzureQueueStorageAdapter (Produção)**
```csharp
// Usa Azure Queue Storage
var adapter = new AzureQueueStorageAdapter(connectionString);
await adapter.SendAsync("fila", mensagem);
```

**Quando usar:**
- ✅ Produção em Azure
- ✅ Alto volume (milhões de mensagens)
- ✅ Custo baixo (pay-per-operation)

### **2. InMemoryMessageQueue (Testes)**
```csharp
// Memória local (sem dependência externa)
var queue = new InMemoryMessageQueue();
await queue.SendAsync("fila", mensagem);

// Testar
var messages = queue.GetMessages<MensagemDto>("fila");
```

**Quando usar:**
- ✅ Testes unitários
- ✅ Desenvolvimento local (sem Azurite)
- ✅ CI/CD pipelines

---

## 🚀 **Como Adicionar Novo Provedor**

### **Exemplo: RabbitMQ**

```csharp
// 1. Criar adapter
public class RabbitMQAdapter : IMessageQueue
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    
    public RabbitMQAdapter(string rabbitMqConnectionString)
    {
        var factory = new ConnectionFactory { Uri = new Uri(rabbitMqConnectionString) };
        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();
    }
    
    public async Task SendAsync<T>(string queueName, T message, CancellationToken ct)
    {
        _channel.QueueDeclare(queueName, durable: true, exclusive: false, autoDelete: false);
        
        var json = JsonSerializer.Serialize(message);
        var bytes = Encoding.UTF8.GetBytes(json);
        
        _channel.BasicPublish(exchange: "", routingKey: queueName, body: bytes);
        await Task.CompletedTask;
    }
}

// 2. Registrar no DI
services.AddSingleton<IMessageQueue>(
    new RabbitMQAdapter(rabbitMqConnectionString));
```

✅ **Application não precisa mudar NADA!**

---

## 📊 **Comparação de Provedores**

| Provedor | Custo | Performance | Complexidade | Uso |
|----------|-------|-------------|--------------|-----|
| **Azure Queue** | 💰 Baixo | ⚡ Alto | 🔧 Simples | Produção |
| **RabbitMQ** | 💰💰 Médio | ⚡⚡ Muito Alto | 🔧🔧 Média | Enterprise |
| **In-Memory** | 💰 Zero | ⚡⚡⚡ Máximo | 🔧 Trivial | Testes |
| **AWS SQS** | 💰 Baixo | ⚡ Alto | 🔧 Simples | AWS Cloud |

---

## 🎓 **Lições Aprendidas**

### **✅ CERTO**
1. Interface genérica no Application
2. Implementação específica no Infrastructure
3. Nome "Adapter" para infraestrutura
4. Dependency Injection para trocar facilmente

### **❌ ERRADO (evitado)**
1. ~~Application conhecendo Azure diretamente~~
2. ~~Nome "Service" para código de infraestrutura~~
3. ~~Interface específica (`IFilaRespostaService`)~~
4. ~~Criar fila no construtor (lazy creation é melhor)~~

---

## 📚 **Referências**

- [Clean Architecture - Uncle Bob](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)
