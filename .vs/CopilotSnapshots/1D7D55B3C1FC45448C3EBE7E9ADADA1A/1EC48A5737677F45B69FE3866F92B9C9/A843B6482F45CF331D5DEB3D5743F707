using QuestionarioOnline.Application.DTOs;
using QuestionarioOnline.Application.Interfaces;
using QuestionarioOnline.Domain.Entities;
using QuestionarioOnline.Domain.Interfaces;
using QuestionarioOnline.Domain.ValueObjects;
using System.Security.Cryptography;
using System.Text;

namespace QuestionarioOnline.Application.Services;

public class UsuarioInternoService : IUsuarioInternoService
{
    private readonly IUsuarioInternoRepository _usuarioInternoRepository;

    public UsuarioInternoService(IUsuarioInternoRepository usuarioInternoRepository)
    {
        _usuarioInternoRepository = usuarioInternoRepository;
    }

    public async Task<UsuarioInternoDto> CriarUsuarioAsync(CriarUsuarioInternoRequest request, CancellationToken cancellationToken = default)
    {
        var email = Email.Create(request.Email);

        var emailJaExiste = await _usuarioInternoRepository.ExisteEmailAsync(email, cancellationToken);

        if (emailJaExiste)
            throw new InvalidOperationException("Email já cadastrado");

        var senhaHash = GerarHashSenha(request.Senha);

        var usuario = new UsuarioInterno(request.Nome, email, senhaHash);

        await _usuarioInternoRepository.AdicionarAsync(usuario, cancellationToken);

        return MapearParaDto(usuario);
    }

    public async Task<AutenticacaoResultDto> AutenticarAsync(AutenticarUsuarioRequest request, CancellationToken cancellationToken = default)
    {
        var email = Email.Create(request.Email);
        var usuario = await _usuarioInternoRepository.ObterPorEmailAsync(email, cancellationToken);

        if (usuario is null)
        {
            return new AutenticacaoResultDto(false, null, null, "Email ou senha inválidos");
        }

        if (!usuario.Ativo)
        {
            return new AutenticacaoResultDto(false, null, null, "Usuário inativo");
        }

        var senhaHash = GerarHashSenha(request.Senha);

        if (usuario.SenhaHash != senhaHash)
        {
            return new AutenticacaoResultDto(false, null, null, "Email ou senha inválidos");
        }

        // TODO: Gerar JWT Token real na camada CrossCutting
        var token = $"token_{usuario.Id}";

        return new AutenticacaoResultDto(true, token, MapearParaDto(usuario), "Autenticação realizada com sucesso");
    }

    public async Task<UsuarioInternoDto?> ObterPorIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var usuario = await _usuarioInternoRepository.ObterPorIdAsync(id, cancellationToken);

        return usuario is not null ? MapearParaDto(usuario) : null;
    }

    private static string GerarHashSenha(string senha)
    {
        var bytes = Encoding.UTF8.GetBytes(senha);
        var hash = SHA256.HashData(bytes);
        return Convert.ToHexString(hash).ToLowerInvariant();
    }

    private static UsuarioInternoDto MapearParaDto(UsuarioInterno usuario)
    {
        return new UsuarioInternoDto(
            usuario.Id,
            usuario.Nome,
            usuario.Email.Address,
            usuario.DataCriacao,
            usuario.Ativo
        );
    }
}
