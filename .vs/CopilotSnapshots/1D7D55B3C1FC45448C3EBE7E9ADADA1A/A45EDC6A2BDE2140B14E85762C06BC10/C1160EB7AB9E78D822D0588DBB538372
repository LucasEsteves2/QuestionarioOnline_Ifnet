# ?? Sistema de Questionários Online

[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=flat&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-12.0-239120?style=flat&logo=c-sharp)](https://docs.microsoft.com/en-us/dotnet/csharp/)
[![Azure](https://img.shields.io/badge/Azure-Queue%20Storage-0089D6?style=flat&logo=microsoft-azure)](https://azure.microsoft.com/)
[![Infnet](https://img.shields.io/badge/Infnet-Pós--Graduação-red.svg)](https://www.infnet.edu.br/)

> Projeto desenvolvido como Trabalho de Conclusão da **Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**. Sistema empresarial para criação, gerenciamento e coleta de respostas de questionários com processamento assíncrono de alto volume usando Azure Queue Storage.

---

## ?? **Índice**

- [Contexto Acadêmico](#-contexto-acadêmico)
- [Sobre o Projeto](#-sobre-o-projeto)
- [Desafio de Negócio](#-desafio-de-negócio)
- [Arquitetura](#-arquitetura)
- [Domínio e Entidades](#-domínio-e-entidades)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Decisões Arquiteturais](#-decisões-arquiteturais)
- [Tecnologias](#-tecnologias)
- [Funcionalidades e Endpoints](#-funcionalidades-e-endpoints)
- [Instalação e Configuração](#-instalação-e-configuração)
- [Performance e Escalabilidade](#-performance-e-escalabilidade)
- [Documentação Adicional](#-documentação-adicional)

---

## ?? **Contexto Acadêmico**

Este projeto foi desenvolvido como **Trabalho de Conclusão da Pós-Graduação em Arquitetura de Software** do **Instituto Infnet**, sob a perspectiva de um **Arquiteto de Software** responsável por projetar uma solução escalável e de alta performance para uma startup.

### **Requisitos do Projeto Acadêmico**

**Cenário:**
Uma startup precisa de um sistema de questionários online para pesquisas públicas sobre eleições, com capacidade de receber respostas de **milhões de pessoas** simultaneamente através de campanhas em redes sociais.

**Restrições:**
- ? Time de **5 desenvolvedores** com conhecimento em **.NET e C#**
- ? Obrigatoriedade de uso do **ecossistema .NET**
- ? **Prazo crítico**: Eleições se aproximando (urgência de entrega)
- ? Escala: Suportar **milhões de respostas** simultâneas
- ? Simplicidade: Perguntas de **múltipla escolha**

**Objetivo:**
Elaborar diagramas (UML/C4 Model) e justificar escolhas arquiteturais para dois públicos:
1. **Desenvolvedores** (visão técnica)
2. **Usuários/Stakeholders** (visão de negócio)

---

## ?? **Sobre o Projeto**

O **Sistema de Questionários Online** é uma solução empresarial desenvolvida com **.NET 8** que permite a criação e gerenciamento de questionários por usuários internos (analistas da startup) e a coleta massiva de respostas de usuários externos (eleitores) de forma escalável e assíncrona.

### **Público-Alvo**
- **Usuários Internos**: Equipe da startup (criação e análise de pesquisas)
- **Usuários Externos**: Milhões de eleitores respondendo pesquisas via redes sociais
- **Desenvolvedores**: Time de 5 devs .NET/C# que implementarão a solução

---

## ?? **Desafio de Negócio**

Startups de pesquisa eleitoral enfrentam desafios críticos durante campanhas em redes sociais:

**?? Volume Massivo e Imprevisível**
- ?? **Picos de acesso**: Posts virais podem gerar 10k+ respostas simultâneas
- ?? **Sobrecarga do servidor**: Infraestrutura tradicional não escala rapidamente

**?? Performance Crítica**
- ?? **Timeout**: Usuários abandonam se a resposta demora >3 segundos
- ?? **Perda de dados**: Falhas durante picos causam perda de respostas valiosas

**?? Prazo Apertado**
- ?? **Eleições se aproximando**: Entrega fora do prazo = prejuízo total
- ?? **Time pequeno**: 5 desenvolvedores precisam entregar rápido

---

## ??? **Arquitetura**

### **Visão Geral da Solução**

A arquitetura do projeto foi estruturada seguindo os princípios de **Clean Architecture** combinada com **Domain-Driven Design (DDD)**, resultando em um **Monolito Modular** com **processamento assíncrono via fila de mensagens**.

```mermaid
graph TB
    subgraph "?? PRESENTATION LAYER"
        API[Web API<br/>Controllers, Middleware, JWT]
    end

    subgraph "?? APPLICATION LAYER"
        Services[Services<br/>Orquestração e Validação]
    end

    subgraph "?? DOMAIN LAYER"
        Entities[Entities<br/>Regras de Negócio]
    end

    subgraph "?? INFRASTRUCTURE LAYER"
        Repos[Repositories<br/>EF Core, Azure Queue]
    end

    subgraph "?? CROSS-CUTTING LAYER"
        DI[Dependency Injection<br/>Extensions, Constants]
    end

    subgraph "? WORKERS LAYER"
        Functions[Azure Functions<br/>Background Processing]
    end

    API --> Services
    Services --> Entities
    Services --> Repos
    DI -.-> API
    DI -.-> Services
    DI -.-> Repos
    Functions --> Repos

    style Entities fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Services fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style API fill:#e1f5ff,stroke:#01579b,stroke-width:2px
    style Repos fill:#d1c4e9,stroke:#4527a0,stroke-width:2px
    style DI fill:#ffccbc,stroke:#d84315,stroke-width:2px
    style Functions fill:#424242,stroke:#212121,stroke-width:2px
```

**Princípios aplicados:**
- ? **Clean Architecture**: Camadas isoladas com inversão de dependência
- ? **DDD**: Aggregate Roots, Value Objects, Rich Domain Model
- ? **Processamento Assíncrono**: Fila absorve picos de carga
- ? **Monolito Modular**: Simplicidade agora, evolução futura facilitada

---

### **Fluxo de Dados (Operações Síncronas)**

Para operações administrativas (criar questionários, consultar resultados, autenticação), o sistema opera de forma **síncrona** através das camadas da Clean Architecture:

```mermaid
sequenceDiagram
    actor User as ?? Usuário Interno
    participant API as ?? API<br/>(Controller)
    participant App as ?? Application<br/>(Service)
    participant Domain as ?? Domain<br/>(Entity)
    participant Infra as ?? Infrastructure<br/>(Repository)
    participant DB as ?? SQL Server

    User->>API: HTTP Request
    activate API
    
    API->>API: Validar JWT
    API->>App: Chamar Service
    activate App
    
    App->>Domain: Criar/Manipular Entidade
    activate Domain
    Domain->>Domain: Validar Regras de Negócio
    Domain-->>App: Entidade Válida
    deactivate Domain
    
    App->>Infra: Chamar Repository
    activate Infra
    Infra->>DB: SQL Query (EF Core)
    DB-->>Infra: Resultado
    Infra-->>App: Entidade Persistida
    deactivate Infra
    
    App-->>API: Result<T> (Success/Failure)
    deactivate App
    
    API-->>User: HTTP Response (ApiResponse)
    deactivate API
```

**Características:**
- **Usado para**: Criar questionários, consultar resultados, autenticação
- **Latência**: ~50-100ms (aceitável para operações administrativas)
- **Garantias**: Transações ACID, feedback imediato, validação em tempo real

---

### **Fluxo de Dados (Operações Assíncronas)**

Para coleta massiva de respostas (alto volume), o sistema utiliza **processamento assíncrono** via fila de mensagens para garantir escalabilidade:

```mermaid
sequenceDiagram
    participant User as ?? Usuário Externo
    participant API as Web API
    participant Queue as Azure Queue
    participant Function as Azure Function
    participant DB as SQL Server

    User->>API: POST /api/resposta
    activate API
    
    API->>API: Validar Questionário
    API->>Queue: Enfileirar Mensagem
    activate Queue
    Queue-->>API: Enfileirado com sucesso
    deactivate Queue
    
    API-->>User: 202 Accepted<br/>(Processando em background)
    deactivate API
    
    Note over Queue,Function: Processamento<br/>em Background
    
    Queue->>Function: Trigger (nova mensagem)
    activate Function
    
    Function->>Function: Deserializar DTO
    Function->>DB: Persistir Resposta
    activate DB
    DB-->>Function: Sucesso
    deactivate DB
    
    Function-->>Queue: Marcar como processada
    deactivate Function
```

**Características:**
- **Usado para**: Receber respostas de pesquisas (10.000+ simultâneas)
- **Latência da API**: <5ms (usuário não espera processamento)
- **Processamento**: 100-500ms por resposta (em background)
- **Escalabilidade**: Azure Functions escalam automaticamente (0 a 1000 instâncias)

**Benefícios mensuráveis:**

| Cenário | Síncrono ? | Assíncrono ? |
|---------|-------------|---------------|
| **10.000 respostas em 1 minuto** | 83 minutos (timeout) | 50 segundos (sucesso) |
| **Taxa de sucesso** | 2% (98% perdidas) | 100% (enfileiradas) |
| **Experiência do usuário** | Aguarda 500ms+ | Feedback em <5ms |
| **Resiliência** | Sem retry | Retry automático + DLQ |

---

### **Visão C4 (Container)**

O diagrama C4 Model ilustra os containers e suas interações:

```mermaid
C4Container
    title Sistema de Questionários Online

    Person(user_interno, "Usuário Interno<br/>(Startup)")
    Person(user_externo, "Usuário Externo<br/>(Eleitor)")

    Container_Boundary(system, "Sistema") {
        Container(api, "Web API", ".NET 8")
        Container(function, "Azure Function", ".NET 8")
        ContainerDb(db, "Database", "SQL Server")
        ContainerQueue(queue, "Queue", "Azure Storage")
    }

    Rel(user_interno, api, "Gerencia questionários", "HTTPS/JWT")
    Rel(user_externo, api, "Responde pesquisas", "HTTPS")
    Rel(api, queue, "Enfileira respostas", "Azure SDK")
    Rel(api, db, "CRUD questionários", "EF Core")
    Rel(function, queue, "Consome mensagens", "Trigger")
    Rel(function, db, "Persiste respostas", "EF Core")
```

---

## ?? **Domínio e Entidades**

O sistema foi modelado seguindo **Domain-Driven Design (DDD)**, com **3 Aggregate Roots** principais que encapsulam regras de negócio:

```mermaid
classDiagram
    class Questionario {
        <<Aggregate Root>>
        +Guid Id
        +string Titulo
        +StatusQuestionario Status
        +PeriodoColeta PeriodoColeta
        +Guid UsuarioId
        +IReadOnlyCollection~Pergunta~ Perguntas
        +Criar()$ Questionario
        +AdicionarPergunta(pergunta)
        +Encerrar()
        +PodeReceberRespostas() bool
    }

    class Pergunta {
        +Guid Id
        +string Texto
        +int Ordem
        +bool Obrigatoria
        +IReadOnlyCollection~OpcaoResposta~ Opcoes
    }

    class OpcaoResposta {
        +Guid Id
        +string Texto
        +int Ordem
    }

    class Resposta {
        <<Aggregate Root>>
        +Guid Id
        +Guid QuestionarioId
        +OrigemResposta OrigemResposta
        +DateTime DataResposta
        +IReadOnlyCollection~RespostaItem~ Itens
        +Criar()$ Resposta
        +AdicionarItem(item)
        +ValidarCompletude(perguntas)
    }

    class RespostaItem {
        +Guid Id
        +Guid PerguntaId
        +Guid OpcaoRespostaId
    }

    class Usuario {
        <<Aggregate Root>>
        +Guid Id
        +string Nome
        +Email Email
        +UsuarioRole Role
        +bool Ativo
        +ValidarSenha(senha) bool
        +AlterarRole(role)
    }

    Questionario "1" *-- "0..*" Pergunta
    Pergunta "1" *-- "2..*" OpcaoResposta
    Resposta "1" *-- "1..*" RespostaItem
    Questionario --> Usuario
    Resposta --> Questionario
    RespostaItem --> Pergunta
    RespostaItem --> OpcaoResposta

    style Questionario fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Resposta fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Usuario fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
```

### **Aggregate Roots**

**⭐ Questionario (Gerenciamento de Pesquisas)**
- **Responsabilidade**: Gerencia perguntas e opções com consistência transacional
- **Regras de negócio**: 
  - Factory Method `Criar()` garante estado válido inicial
  - `PodeReceberRespostas()` verifica período de coleta e status
  - `Encerrar()` muda status para `Encerrado` (imutável depois)
  - **Vinculação**: `UsuarioId` identifica o criador do questionário
- **Value Object**: `PeriodoColeta` (DataInicio, DataFim com validação)

**⭐ Resposta (Coleta de Votos)**
- **Responsabilidade**: Gerencia itens de resposta e valida completude
- **Regras de negócio**:
  - `ValidarCompletude()` garante que todas perguntas obrigatórias foram respondidas
  - `AdicionarItem()` valida se pergunta pertence ao questionário
  - **Anonimato**: Não vincula usuário, apenas `OrigemResposta` (hash IP + UserAgent)
- **Value Object**: `OrigemResposta` (para detectar duplicatas sem identificar eleitor)

**⭐ Usuario (Autenticação)**
- **Responsabilidade**: Gerencia autenticação de analistas da startup
- **Regras de negócio**:
  - `ValidarSenha()` com BCrypt (hash + salt automático)
  - `Ativo` flag (desabilitar sem deletar)
  - `AlterarRole()` para mudança de papéis (Admin, Visualizador)
- **Value Object**: `Email` (validação de formato)

---

## ?? **Estrutura do Projeto**

A organização do código segue rigorosamente a **Clean Architecture**, com cada camada em um projeto separado para garantir baixo acoplamento e alta coesão:

```
QuestionarioOnline/
?
??? ?? QuestionarioOnline.Api/              # ?? PRESENTATION LAYER
?   ??? Controllers/
?   ?   ??? QuestionarioController.cs       # CRUD de questionários
?   ?   ??? RespostaController.cs           # Enfileirar respostas
?   ?   ??? AuthController.cs               # Login JWT
?   ??? Services/
?   ?   ??? AuthService.cs                  # Geração de tokens JWT
?   ??? Responses/
?   ?   ??? ApiResponse.cs                  # Padronização de responses
?   ??? Program.cs                           # Startup (DI, Middleware, Swagger)
?
??? ?? QuestionarioOnline.Application/       # ?? APPLICATION LAYER
?   ??? Services/
?   ?   ??? QuestionarioService.cs          # Casos de uso (Criar, Listar, Encerrar)
?   ?   ??? RespostaService.cs              # Enfileirar resposta
?   ??? Interfaces/
?   ?   ??? IQuestionarioService.cs
?   ?   ??? IRespostaService.cs
?   ??? DTOs/
?   ?   ??? Requests/
?   ?   ?   ??? CriarQuestionarioRequest.cs
?   ?   ?   ??? RegistrarRespostaRequest.cs
?   ?   ??? Responses/
?   ?       ??? QuestionarioDto.cs
?   ?       ??? RespostaRegistradaDto.cs
?   ??? Validators/
?       ??? CriarQuestionarioValidator.cs    # FluentValidation
?
??? ?? QuestionarioOnline.Domain/            # ?? DOMAIN LAYER (CORE)
?   ??? Entities/
?   ?   ??? Questionario.cs ?              # Aggregate Root (Factory, regras)
?   ?   ??? Resposta.cs ?                  # Aggregate Root (validação)
?   ?   ??? Usuario.cs ?                    # Aggregate Root (autenticação)
?   ??? ValueObjects/
?   ?   ??? Email.cs                         # Validação de formato
?   ?   ??? PeriodoColeta.cs                 # DataInicio < DataFim
?   ?   ??? OrigemResposta.cs                # Hash para anonimato
?   ??? Enums/
?   ?   ??? StatusQuestionario.cs            # Ativo, Encerrado, Rascunho
?   ??? Interfaces/
?       ??? IQuestionarioRepository.cs       # Contrato (sem implementação)
?       ??? IRespostaRepository.cs
?       ??? IMessageQueue.cs                 # Abstração da fila
?
??? ?? QuestionarioOnline.Infrastructure/    # ?? INFRASTRUCTURE LAYER
?   ??? Persistence/
?   ?   ??? QuestionarioOnlineDbContext.cs   # EF Core DbContext
?   ?   ??? Configurations/                  # FluentAPI (14 configurações)
?   ?   ?   ??? QuestionarioConfiguration.cs # Índices, relacionamentos
?   ?   ?   ??? PerguntaConfiguration.cs
?   ?   ?   ??? OpcaoRespostaConfiguration.cs
?   ?   ?   ??? RespostaConfiguration.cs
?   ?   ?   ??? RespostaItemConfiguration.cs
?   ?   ?   ??? UsuarioConfiguration.cs
?   ?   ??? DbInitializer.cs                 # Seed de dados (dev)
?   ??? Repositories/
?   ?   ??? QuestionarioRepository.cs        # Implementação + AsNoTracking
?   ?   ??? RespostaRepository.cs
?   ?   ??? UsuarioRepository.cs
?   ??? Messaging/
?       ??? AzureQueueStorageAdapter.cs      # Implementa IMessageQueue
?       ??? MessageQueueOptions.cs           # Configuração
?
??? ?? QuestionarioOnline.CrossCutting/      # ?? CROSS-CUTTING LAYER
?   ??? DependencyInjection/
?       ??? DependencyInjectionConfig.cs     # Registro de serviços, repos
?
??? ?? QuestionarioOnline.Workers.Function/  # ? WORKERS LAYER
?   ??? ProcessarRespostaFunction.cs         # Azure Function (Queue Trigger)
?   ??? Program.cs                           # Configuração
?
??? ?? docs/                                  # ?? Documentação Técnica
    ??? ARQUITETURA_COMPLETA.md
    ??? EF_CORE_CONFIGURATION.md
    ??? JWT_AUTHENTICATION_GUIDE.md
    ??? MELHORIAS_PERFORMANCE.md
```

**Benefícios dessa organização:**
- ? **Separação clara**: Cada camada em um projeto separado (namespace isolado)
- ? **Testabilidade**: Domain e Application testados sem Infrastructure
- ? **Manutenibilidade**: Mudanças em uma camada não afetam outras
- ? **Evolução**: Fácil extrair módulos para microservices (fronteiras já existem)

---

## ? **Decisões Arquiteturais**

### **1. ??? Por que Monolito Modular (não Microservices)?**

**Contexto:**  
Startup com time de 5 desenvolvedores e prazo de 3 meses para entregar sistema funcional antes das eleições.

**Decisão:**  
Adotar **Monolito Modular** com **Clean Architecture**, mantendo fronteiras claras entre módulos (Questionario, Resposta, Auth) para facilitar futura extração como microservices.

**Justificativas:**

**? Pragmatismo:**
- **Prazo crítico**: Monolito = 3 meses de desenvolvimento | Microservices = 6+ meses
- **Setup simplificado**: 1 repositório, 1 pipeline CI/CD, 1 deploy
- **Debug facilitado**: Stack traces completos, sem rastreamento distribuído
- **Transações ACID**: Operações atômicas nativas (CREATE Questionario + Perguntas em 1 transação)

**? Time pequeno:**
- **5 desenvolvedores = 1 squad**: Todos trabalham no mesmo repositório
- **Conhecimento compartilhado**: Pull requests revisados por todos
- **Baixo overhead**: Sem necessidade de orquestração de múltiplos serviços

**?? Trade-off aceito:**
- **Escala acoplada**: API, Questionario e Auth escalam juntos (mesma VM)
  - **Mitigação**: Processamento assíncrono via fila desacopla o pico de carga de respostas
- **Deploy all-or-nothing**: Mudança em Auth exige deploy completo
  - **Aceitável para MVP**: Entregas rápidas são mais importantes que deploy granular

**Caminho evolutivo:**
```
Fase 1 (Hoje - 3 meses):   Monolito Modular
Fase 2 (6-12 meses):        Worker separado (primeira extração)
Fase 3 (12-18 meses):       Microservices completo (se necessário)
```

---

### **2. ?? Por que Processamento Assíncrono (Fila + Azure Functions)?**

**Contexto:**  
Sistema precisa receber **10.000+ respostas simultâneas** durante campanhas virais em redes sociais (Instagram, Twitter, etc.). Processamento síncrono causaria timeout e perda de dados.

**Decisão:**  
Adotar **fila de mensagens (Azure Queue Storage)** + **Azure Functions** para processar respostas em background, retornando `202 Accepted` imediatamente para o usuário.

**Justificativas:**

**? Performance crítica:**
- **API responde em <5ms**: Enfileira mensagem e retorna imediatamente
- **Sem timeout**: Processamento pode levar minutos sem afetar experiência
- **Latência previsível**: Independente de quantas respostas chegam, API sempre responde rápido

**Cenário real (post viral):**
```
10.000 respostas em 1 minuto:

? Processamento síncrono:
   10.000 × 500ms = 5.000 segundos (83 minutos)
   - Timeout após 30s
   - 98% das respostas perdidas

? Processamento assíncrono:
   10.000 × 5ms = 50 segundos
   - 100% de sucesso (202 Accepted)
   - Worker processa em 2 minutos (background)
```

**? Escalabilidade automática:**
- **Azure Functions escalam de 0 a 1000 instâncias** baseado no tamanho da fila
- **Custo otimizado**: Paga apenas pelo que usa (serverless pay-per-use)

**? Resiliência:**
- **Mensagens persistidas**: Se Worker crashar, mensagem volta para fila
- **Retry automático**: 5 tentativas com backoff exponencial
- **Dead Letter Queue (DLQ)**: Mensagens problemáticas vão para fila secundária

**?? Por que não:**
- ? **Service Bus**: Custo 3x maior, features desnecessárias (tópicos, subscriptions)
- ? **HTTP síncrono**: Timeout, sem retry, perda de dados em falhas
- ? **RabbitMQ**: Exige gerenciar infraestrutura (VM, cluster, HA)

---

### **3. ?? Por que SQL Server + EF Core (não NoSQL)?**

**Contexto:**  
Dados eleitorais exigem **integridade transacional** (ACID) e **queries analíticas complexas** (agregações por Estado, Cidade, Região).

**Decisão:**  
Usar **SQL Server** com **Entity Framework Core 8**, aplicando otimizações (AsNoTracking, índices, paginação).

**Justificativas:**

**? ACID crítico:**
- **Integridade transacional**: Criar Questionario + Perguntas + Opções em 1 transação atômica
- **Zero margem de erro**: Dados eleitorais não podem ser inconsistentes
- **Rollback automático**: Se falhar qualquer operação, reverte tudo

**? Expertise do time:**
- **5 devs já conhecem SQL Server**: Curva de aprendizado zero
- **Ferramentas maduras**: SSMS, Azure Data Studio, Application Insights

**? Otimizações aplicadas:**
- **AsNoTracking** (+30% performance): Queries de leitura sem Change Tracker
- **14 índices estratégicos** (+40x buscas): QuestionarioId, Estado, Cidade
- **Paginação** (Skip/Take): Suporta 100k+ questionários sem memory overflow

**?? Por que não NoSQL:**
- ? **MongoDB/Cosmos DB**: Eventual consistency = risco para dados eleitorais
- ? **Sem JOIN nativo**: Queries analíticas complexas exigem múltiplas chamadas

---

### **4. 🔐 Por que JWT Stateless (não Session-based)?**

**Contexto:**  
Sistema precisa escalar horizontalmente (múltiplas instâncias da API) sem compartilhar estado entre servidores.

**Decisão:**  
Usar **JWT Bearer** para autenticação stateless.

**Justificativas:**

**✅ Escalabilidade horizontal:**
- **Zero estado compartilhado**: Cada instância valida JWT independentemente
- **Sem Redis/Memcached**: Não precisa cache distribuído para sessions
- **Load Balancer simples**: Qualquer instância pode atender qualquer request

**✅ Performance:**
- **Sem consulta ao DB**: Token contém claims (usuarioId, email, roles)
- **Validação local**: Verifica assinatura HMAC-SHA256 (milissegundos)

**⚠️ Por que não Session-based:**
- ❌ Exige Redis/cache distribuído (complexidade)
- ❌ Estado compartilhado entre instâncias (acoplamento)

---

### **5. 🗳️ Por que NÃO vinculamos o eleitor que vota?**

**Contexto:**  
Sistema de pesquisas eleitorais públicas precisa garantir anonimato dos eleitores enquanto impede votos duplicados.

**Decisão:**  
**NÃO armazenar** identificação pessoal do eleitor. Usar **hash SHA256** (IP + UserAgent) para validar duplicatas sem identificar pessoas.

**Justificativas:**

**✅ Legalidade e Ética:**
- **Pesquisas eleitorais públicas devem ser anônimas** (legislação eleitoral)
- **LGPD/GDPR**: Armazenar dados pessoais exige consentimento e compliance
- **Liberdade de expressão**: Eleitor vota sem medo de retaliação

**✅ Escalabilidade:**
- **Sem autenticação**: Milhões de pessoas votam sem precisar criar conta
- **Performance**: Sem consultas a tabela de usuários (apenas validação de hash)
- **Simplicidade**: Endpoint público (`POST /api/resposta`) sem JWT

**✅ Segurança e Privacidade:**
- **Zero dados sensíveis**: Sem CPF, email, nome, telefone
- **Risco baixo de vazamento**: Apenas hash irreversível no banco
- **Confiança do público**: Anonimato garantido aumenta participação

**📊 Como Garantimos Integridade SEM Identificação?**

```csharp
// Value Object - OrigemResposta
public static OrigemResposta Create(string ipAddress, string userAgent)
{
    // Gera hash SHA256 irreversível (não armazena IP/UserAgent real)
    var combined = $"{ipAddress}|{userAgent}";
    var hash = ComputeSha256(combined);  // Exemplo: "A3F5D8B2..."
    
    return new OrigemResposta(hash);
}
```

**O que o hash permite:**
- ✅ **Impedir voto duplicado**: Verifica se hash já existe no questionário
- ✅ **Análise demográfica**: Armazena Estado, Cidade, Região (dados agregados)
- ✅ **Detectar fraude em massa**: Muitas respostas do mesmo hash = suspeito
- ❌ **NÃO permite**: Identificar eleitor específico (hash é irreversível)

**Estrutura no Banco:**
```sql
CREATE TABLE Respostas (
    Id uniqueidentifier PRIMARY KEY,
    QuestionarioId uniqueidentifier NOT NULL,
    OrigemResposta_Hash nvarchar(64) NOT NULL,  -- SHA256 (anônimo!)
    Estado nvarchar(50),  -- Apenas dados demográficos
    Cidade nvarchar(100),
    DataResposta datetime2 NOT NULL
);

-- ❌ SEM: UsuarioId, CPF, Email, IP real, Nome
```

**Trade-off aceito:**
- ⚠️ **Limitação**: Eleitor do mesmo IP/navegador não pode votar 2x (mesmo questionário)
  - **Mitigação**: Aceitável para pesquisas eleitorais (1 voto por pessoa é o objetivo)
- ⚠️ **Fraude por VPN**: Eleitor pode mudar IP para votar múltiplas vezes
  - **Mitigação**: Dead Letter Queue + análise manual de padrões suspeitos

---

### **6. 🏗️ Por que Clean Architecture + DDD?**

**Contexto:**  
Time de 5 devs precisa trabalhar em paralelo sem conflitos, com código testável e preparado para evolução.

**Decisão:**  
Aplicar **Clean Architecture** (camadas isoladas) + **DDD** (Aggregate Roots, Value Objects).

**Justificativas:**

**✅ Manutenibilidade:**
- **Separação clara**: Cada dev trabalha em camada diferente
- **Baixo acoplamento**: Mudança em Infrastructure não afeta Domain
- **Código legível**: Regras de negócio isoladas em Domain

**✅ Testabilidade:**
- **Domain isolado**: Testes unitários sem mocks complexos
- **Interfaces**: Application depende de IRepository (mock fácil)

**✅ Evolução para Microservices:**
- **Fronteiras claras**: Cada módulo já está isolado
- **Comunicação via interfaces**: Fácil substituir por chamadas HTTP/gRPC

---

## 🛠️ **Tecnologias**

### **Backend**
- **.NET 8** - LTS até 2026
- **ASP.NET Core** - Web API
- **C# 12** - Records, pattern matching

### **Banco de Dados**
- **SQL Server / Azure SQL** - ACID + HA
- **Entity Framework Core 8** - ORM otimizado
- **FluentAPI** - Configuração explícita

### **Mensageria**
- **Azure Queue Storage** - Serverless, durável
- **Azure Functions** - Escala automática

### **Autenticação**
- **JWT Bearer** - Stateless
- **BCrypt.Net** - Hash de senhas

### **Validação**
- **FluentValidation** - Validação declarativa

### **Padrões**
- **Clean Architecture** (Uncle Bob)
- **Domain-Driven Design** (Eric Evans)
- **Repository Pattern**
- **Result Pattern** (Railway-Oriented)
- **Role-Based Access Control (RBAC)**

---

## ✨ **Funcionalidades e Endpoints**

### **Sistema de Permissões (Roles)**

O sistema implementa **controle de acesso baseado em papéis (RBAC)** com 3 níveis:

| Role | Permissões | Caso de Uso |
|------|-----------|-------------|
| **Analista** | Criar questionários, ver seus próprios resultados | Usuário padrão da startup |
| **Admin** | Ver resultados de TODOS os questionários, gerenciar sistema | Gestor da startup |
| **Visualizador** | Ver resultados de TODOS os questionários (somente leitura) | Stakeholders, investidores |

**Regras de Negócio:**
- ✅ **Analista**: Apenas vê resultados dos questionários que ele criou
- ✅ **Admin**: Vê resultados de qualquer questionário
- ✅ **Visualizador**: Vê resultados de qualquer questionário (somente leitura)
- ✅ **Role padrão**: Novos usuários são cadastrados como `Analista`

**Implementação Técnica:**
- Role armazenada no JWT (`ClaimTypes.Role`)
- Validação via `[Authorize(Roles = "Admin,Analista,Visualizador")]`
- Enum `UsuarioRole` no Domain Layer

---

### **Autenticação**

| Método | Endpoint | Descrição | Autenticação |
|--------|----------|-----------|--------------|
| `POST` | `/api/auth/register` | Cadastrar novo usuário | ❌ Público |
| `POST` | `/api/auth/login` | Login com email/senha | ❌ Público |

**Exemplo - Cadastrar Usuário:**
```http
POST /api/auth/register
Content-Type: application/json

{
  "nome": "Analista Teste",
  "email": "analista@empresa.com",
  "senha": "Senha123"
}
```

**Response (201 Created):**
```json
{
  "success": true,
  "data": {
    "usuarioId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "nome": "Analista Teste",
    "email": "analista@empresa.com"
  },
  "message": "Usuário cadastrado com sucesso. Faça login para obter o token."
}
```

**Observação:** Usuário é criado com role `Analista` por padrão. Para alterar para `Admin` ou `Visualizador`, é necessário atualizar diretamente no banco de dados (decisão de segurança).

---

**Exemplo - Login:**
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "analista@empresa.com",
  "senha": "Senha123"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "usuarioId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "nome": "Analista Teste",
    "email": "analista@empresa.com"
  }
}
```

**JWT Payload (decodificado):**
```json
{
  "nameid": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "email": "analista@empresa.com",
  "name": "Analista Teste",
  "role": "Analista",
  "exp": 1234567890
}
```

---

### **Questionários**

| Método | Endpoint | Descrição | Autenticação | Roles Permitidas |
|--------|----------|-----------|--------------|------------------|
| `POST` | `/api/questionario` | Criar questionário | ✅ JWT | Analista, Admin |
| `GET` | `/api/questionario` | Listar questionários do usuário | ✅ JWT | Analista, Admin, Visualizador |
| `GET` | `/api/questionario/{id}` | Obter por ID | ✅ JWT | Analista, Admin, Visualizador |
| `GET` | `/api/questionario/publico/{id}` | Obter público (responder) | ❌ Público | - |
| `POST` | `/api/questionario/{id}/encerrar` | Encerrar questionário | ✅ JWT | Analista (criador), Admin |
| `GET` | `/api/questionario/{id}/resultados` | Obter resultados | ✅ JWT | **Ver abaixo** |

**Controle de Acesso aos Resultados:**
- 🔒 **Analista**: Apenas resultados dos questionários que ele **criou**
- 🔓 **Admin**: Resultados de **TODOS** os questionários
- 👁️ **Visualizador**: Resultados de **TODOS** os questionários (somente leitura)

**Exemplo - Criar Questionário:**
```http
POST /api/questionario
Authorization: Bearer {token}
Content-Type: application/json

{
  "titulo": "Pesquisa Eleitoral 2024",
  "descricao": "Intenção de voto",
  "dataInicio": "2024-01-01T00:00:00Z",
  "dataFim": "2024-12-31T23:59:59Z",
  "perguntas": [
    {
      "texto": "Em quem você votaria?",
      "ordem": 1,
      "obrigatoria": true,
      "opcoes": [
        { "texto": "Candidato A", "ordem": 1 },
        { "texto": "Candidato B", "ordem": 2 }
      ]
    }
  ]
}
```

**Exemplo - Obter Resultados:**
```http
GET /api/questionario/{id}/resultados
Authorization: Bearer {token}
```

**Response (200 OK) - Analista (apenas se for criador):**
```json
{
  "success": true,
  "data": {
    "questionarioId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "titulo": "Pesquisa Eleitoral 2024",
    "totalRespostas": 15234,
    "perguntas": [
      {
        "texto": "Em quem você votaria?",
        "opcoes": [
          { "texto": "Candidato A", "votos": 8500, "percentual": 55.8 },
          { "texto": "Candidato B", "votos": 6734, "percentual": 44.2 }
        ]
      }
    ]
  }
}
```

**Response (401 Unauthorized) - Analista tentando ver questionário de outro:**
```json
{
  "success": false,
  "message": "Você não tem permissão para ver estes resultados",
  "statusCode": 401
}
```
---

## ?? **Instalação e Configuração**

### **Pré-requisitos**

- ? [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0)
- ? [SQL Server](https://www.microsoft.com/sql-server) ou LocalDB
- ? [Azure Storage Emulator](https://learn.microsoft.com/azure/storage/common/storage-use-emulator) ou [Azurite](https://github.com/Azure/Azurite)
- ? [Visual Studio 2022](https://visualstudio.microsoft.com/) ou [VS Code](https://code.visualstudio.com/)

### **Instalação**

**1. Clone o repositório**
```bash
git clone https://github.com/seu-usuario/questionario-online.git
cd questionario-online
```

**2. Restore pacotes NuGet**
```bash
dotnet restore
```

**3. Configure a connection string**

Edite `QuestionarioOnline/appsettings.json`:
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=QuestionarioOnlineDb;Trusted_Connection=True",
    "AzureWebJobsStorage": "UseDevelopmentStorage=true"
  }
}
```

**4. Execute as migrations**
```bash
dotnet run --project QuestionarioOnline
```

O banco será criado automaticamente no primeiro run.

**5. Inicie o Azure Storage Emulator**
```bash
# Windows
AzureStorageEmulator.exe start

# Linux/Mac (use Azurite)
azurite --silent
```

**6. Acesse a API**
```bash
dotnet run --project QuestionarioOnline
```

Swagger: `https://localhost:7xxx/swagger`

---

## ? **Performance e Escalabilidade**

### **Otimizações Implementadas**

| Otimização | Impacto | Descrição |
|------------|---------|-----------|
| **AsNoTracking** | +30% | Queries sem Change Tracker |
| **Índices** | +40x | 14 índices estratégicos |
| **Paginação** | +100x | Skip/Take em listagens |
| **Assíncrono** | ? | Queue + Functions escaláveis |

### **Métricas**

```
? Query ObterPorId: 35ms (antes: 50ms)
? Listagem 100 registros: 50ms (antes: 500ms)
? Registrar resposta: <5ms (202 Accepted)
? Processar 10k respostas: ~2min (paralelo)
```

?? **Análise completa:** [MELHORIAS_PERFORMANCE.md](docs/MELHORIAS_PERFORMANCE.md)

---

## ?? **Documentação Adicional**

| Documento | Descrição |
|-----------|-----------|
| [ARQUITETURA_COMPLETA.md](docs/ARQUITETURA_COMPLETA.md) | Diagramas C4, UML completos |
| [EF_CORE_CONFIGURATION.md](docs/EF_CORE_CONFIGURATION.md) | Entity Framework |
| [JWT_AUTHENTICATION_GUIDE.md](docs/JWT_AUTHENTICATION_GUIDE.md) | Autenticação JWT |
| [MELHORIAS_PERFORMANCE.md](docs/MELHORIAS_PERFORMANCE.md) | Otimizações |

---

## ?? **Contribuindo**

Contribuições são bem-vindas!

1. Fork o projeto
2. Crie uma branch (`git checkout -b feature/MinhaFeature`)
3. Commit (`git commit -m 'feat: Adiciona MinhaFeature'`)
4. Push (`git push origin feature/MinhaFeature`)
5. Abra um Pull Request

---

## ?? **Licença**

Este projeto está sob a licença MIT. Veja [LICENSE](LICENSE) para detalhes.

---

## ?? **Autor**

**Seu Nome** - Pós-Graduação em Arquitetura de Software - Instituto Infnet  
?? [LinkedIn](https://linkedin.com/in/seu-perfil) | ?? [GitHub](https://github.com/seu-usuario)

---

<div align="center">

**? Projeto Acadêmico - Pós-Graduação Infnet ?**

[![Infnet](https://img.shields.io/badge/Infnet-Pós--Graduação-red.svg?style=for-the-badge)](https://www.infnet.edu.br/)
[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=for-the-badge&logo=dotnet)](https://dotnet.microsoft.com/)
[![Clean Architecture](https://img.shields.io/badge/Clean-Architecture-green?style=for-the-badge)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

</div>

---

**Desenvolvido com ?? e rigor técnico para avaliação acadêmica do Instituto Infnet**
